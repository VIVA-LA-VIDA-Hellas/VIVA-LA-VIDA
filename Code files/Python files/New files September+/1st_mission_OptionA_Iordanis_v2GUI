import tkinter as tk
from tkinter import ttk
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import threading
import time
import RPi.GPIO as GPIO
from board import SCL, SDA
import busio
from adafruit_pca9685 import PCA9685

# ===============================
# CONFIGURABLE VARIABLES
# ===============================
TARGET_DISTANCE = 15
FRONT_TURN_TRIGGER = 90
STOP_THRESHOLD = 5
SPEED_CRUISE = 20
TURN_ANGLE_LEFT = 40
TURN_ANGLE_RIGHT = 140
SERVO_CENTER = 90
KP, KI, KD = 1, 0, 2
DEADZONE = 2
MAX_LAPS = 5

# ===============================
# HARDWARE SETUP
# ===============================
i2c = busio.I2C(SCL, SDA)
pca = PCA9685(i2c)
pca.frequency = 50

SERVO_CHANNEL = 0
MOTOR_FWD = 1
MOTOR_REV = 2

GPIO.setmode(GPIO.BCM)
TRIG_FRONT, ECHO_FRONT = 22, 23
TRIG_LEFT, ECHO_LEFT = 27, 17
TRIG_RIGHT, ECHO_RIGHT = 5, 6

for trig in [TRIG_FRONT, TRIG_LEFT, TRIG_RIGHT]:
    GPIO.setup(trig, GPIO.OUT)
    GPIO.output(trig, GPIO.LOW)
for echo in [ECHO_FRONT, ECHO_LEFT, ECHO_RIGHT]:
    GPIO.setup(echo, GPIO.IN)

# ===============================
# ROBOT CONTROL FUNCTIONS
# ===============================
integral = 0
last_error = 0

def set_servo(angle):
    """Move steering servo"""
    angle = max(50, min(130, angle))
    pulse = int(1000 + (2000 - 1000) * ((angle - 50) / (130 - 50)))
    pca.channels[SERVO_CHANNEL].duty_cycle = int(pulse * 65535 / 20000)
    servo_data.append(angle)  # record for graph

def rotate_motor(speed):
    """Forward/backward motor control"""
    duty_cycle = int(min(max(abs(speed), 0), 100) / 100 * 65535)
    if speed >= 0:
        pca.channels[MOTOR_FWD].duty_cycle = duty_cycle
        pca.channels[MOTOR_REV].duty_cycle = 0
    else:
        pca.channels[MOTOR_FWD].duty_cycle = 0
        pca.channels[MOTOR_REV].duty_cycle = duty_cycle

def stop_motor():
    """Stop all motors"""
    pca.channels[MOTOR_FWD].duty_cycle = 0
    pca.channels[MOTOR_REV].duty_cycle = 0

def get_distance(trigger, echo):
    """Ultrasonic sensor distance in cm"""
    GPIO.output(trigger, GPIO.HIGH)
    time.sleep(0.00001)
    GPIO.output(trigger, GPIO.LOW)
    pulse_start, pulse_end = None, None
    timeout = time.time() + 0.02
    while GPIO.input(echo) == GPIO.LOW and time.time() < timeout:
        pulse_start = time.time()
    timeout = time.time() + 0.02
    while GPIO.input(echo) == GPIO.HIGH and time.time() < timeout:
        pulse_end = time.time()
    if pulse_start and pulse_end:
        return (pulse_end - pulse_start) * 17150
    return None

def pid_control(d_left, d_right):
    """Dual/single wall following"""
    global integral, last_error
    error = 0
    if d_left and d_right:  # Dual wall centering
        error = d_left - d_right
    elif d_left:  # Follow left wall
        error = slider_vars["TARGET_DISTANCE"].get() - d_left
    elif d_right:  # Follow right wall
        error = d_right - slider_vars["TARGET_DISTANCE"].get()
    integral += error
    derivative = error - last_error
    last_error = error
    output = (slider_vars["KP"].get() * error +
              slider_vars["KI"].get() * integral +
              slider_vars["KD"].get() * derivative)
    if abs(error) < slider_vars["DEADZONE"].get():
        output = 0
    return output

def turn_decision(d_left, d_right):
    """Pick turn direction"""
    if d_left and d_left > d_right:
        return "LEFT"
    elif d_right and d_right > d_left:
        return "RIGHT"
    return "LEFT"  # default

# ===============================
# TKINTER GUI
# ===============================
root = tk.Tk()
root.title("Robot Control Panel")

# --- Variable sliders ---
var_frame = ttk.LabelFrame(root, text="Variables")
var_frame.grid(row=0, column=0, padx=5, pady=5, sticky="nw")

variables = {
    "TARGET_DISTANCE": [TARGET_DISTANCE, 5, 50],
    "FRONT_TURN_TRIGGER": [FRONT_TURN_TRIGGER, 20, 200],
    "STOP_THRESHOLD": [STOP_THRESHOLD, 1, 20],
    "SPEED_CRUISE": [SPEED_CRUISE, 5, 50],
    "TURN_ANGLE_LEFT": [TURN_ANGLE_LEFT, 0, 90],
    "TURN_ANGLE_RIGHT": [TURN_ANGLE_RIGHT, 90, 180],
    "SERVO_CENTER": [SERVO_CENTER, 50, 130],
    "KP": [KP, 0, 5],
    "KI": [KI, 0, 5],
    "KD": [KD, 0, 5],
    "DEADZONE": [DEADZONE, 0, 10],
    "MAX_LAPS": [MAX_LAPS, 1, 20]
}

slider_vars = {}
row = 0
for name, (val, mn, mx) in variables.items():
    ttk.Label(var_frame, text=name).grid(row=row, column=0, sticky="w")
    slider_var = tk.IntVar(value=val)
    slider = ttk.Scale(var_frame, from_=mn, to=mx, variable=slider_var,
                       orient=tk.HORIZONTAL, length=150)
    slider.grid(row=row, column=1, sticky="w")
    ttk.Label(var_frame, textvariable=slider_var, width=5).grid(row=row, column=2)
    slider_vars[name] = slider_var
    row += 1

# --- Start/Stop buttons ---
start_flag = False
def start_robot():
    global start_flag
    start_flag = True
    start_button.config(state="disabled")
    stop_button.config(state="normal")

def stop_robot():
    global start_flag
    start_flag = False
    stop_motor()
    start_button.config(state="normal")
    stop_button.config(state="disabled")

start_button = ttk.Button(root, text="Start", command=start_robot)
start_button.grid(row=1, column=0, pady=5)
stop_button = ttk.Button(root, text="Stop", command=stop_robot, state="disabled")
stop_button.grid(row=2, column=0, pady=5)

# ===============================
# MATPLOTLIB PLOTS
# ===============================
fig, (ax_front, ax_side, ax_servo) = plt.subplots(3, 1, figsize=(6, 8))
fig.tight_layout(pad=3.0)

# Front sensor
ax_front.set_ylim(0, 200)
ax_front.set_title("Front Sensor")
front_line, = ax_front.plot([], [], color="blue")

# Side sensors
ax_side.set_ylim(0, 200)
ax_side.set_title("Left & Right Sensors")
left_line, = ax_side.plot([], [], label="Left", color="green")
right_line, = ax_side.plot([], [], label="Right", color="red")
ax_side.legend()

# Servo angle
ax_servo.set_ylim(0, 180)
ax_servo.set_title("Servo Angle")
servo_line, = ax_servo.plot([], [], color="orange")

canvas = FigureCanvasTkAgg(fig, master=root)
canvas.get_tk_widget().grid(row=0, column=1, rowspan=6, padx=10, pady=5)

# ===============================
# DATA STORAGE
# ===============================
time_data = []
front_data, left_data, right_data, servo_data = [], [], [], []

# ===============================
# ROBOT LOOP
# ===============================
def robot_loop():
    t = 0
    while True:
        if start_flag:
            d_front = get_distance(TRIG_FRONT, ECHO_FRONT)
            d_left = get_distance(TRIG_LEFT, ECHO_LEFT)
            d_right = get_distance(TRIG_RIGHT, ECHO_RIGHT)

            if d_front and d_front < slider_vars["STOP_THRESHOLD"].get():
                stop_motor()
                continue

            if d_front and d_front < slider_vars["FRONT_TURN_TRIGGER"].get():
                direction = turn_decision(d_left, d_right)
                if direction == "LEFT":
                    set_servo(slider_vars["TURN_ANGLE_LEFT"].get())
                else:
                    set_servo(slider_vars["TURN_ANGLE_RIGHT"].get())
                rotate_motor(slider_vars["SPEED_CRUISE"].get())
                time.sleep(1.0)  # turning duration
                set_servo(slider_vars["SERVO_CENTER"].get())
                stop_motor()
            else:
                output = pid_control(d_left, d_right)
                new_angle = slider_vars["SERVO_CENTER"].get() + output
                set_servo(new_angle)
                rotate_motor(slider_vars["SPEED_CRUISE"].get())

            # Store data
            time_data.append(t)
            front_data.append(d_front if d_front else 0)
            left_data.append(d_left if d_left else 0)
            right_data.append(d_right if d_right else 0)

            if len(time_data) > 100:
                time_data.pop(0)
                front_data.pop(0)
                left_data.pop(0)
                right_data.pop(0)
                servo_data.pop(0)

            # Update plots
            front_line.set_data(time_data, front_data)
            left_line.set_data(time_data, left_data)
            right_line.set_data(time_data, right_data)
            servo_line.set_data(time_data, servo_data)

            ax_front.set_xlim(max(0, t-100), t)
            ax_side.set_xlim(max(0, t-100), t)
            ax_servo.set_xlim(max(0, t-100), t)

            canvas.draw()
            t += 1

        time.sleep(0.1)

threading.Thread(target=robot_loop, daemon=True).start()

root.mainloop()
