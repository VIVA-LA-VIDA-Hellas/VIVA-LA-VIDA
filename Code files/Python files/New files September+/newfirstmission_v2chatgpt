import time
import RPi.GPIO as GPIO
from board import SCL, SDA
import busio
from adafruit_pca9685 import PCA9685

time.sleep(2)

# --- Global State ---
turns_completed = 0
direction = "left"  # start with left wall
turning = False

# --- PCA9685 Setup ---
i2c = busio.I2C(SCL, SDA)
pca = PCA9685(i2c)
pca.frequency = 50  # Default for servos

# --- PID Constants ---
TARGET_DISTANCE = 50.0  # cm (center of 1 m corridor)
KP = 1.0
KI = 0.0
KD = 0.8

integral = 0
last_error = 0
SERVO_CHANNEL = 0

# --- Turn threshold ---
CORNER_TRIGGER = 45.0  # cm

# --- GPIO Setup ---
GPIO.setmode(GPIO.BCM)

TRIG_1, ECHO_1 = 22, 23   # Front sensor
TRIG_2, ECHO_2 = 27, 17   # Left sensor
TRIG_3, ECHO_3 = 5, 6     # Right sensor

for trig in [TRIG_1, TRIG_2, TRIG_3]:
    GPIO.setup(trig, GPIO.OUT)
    GPIO.output(trig, GPIO.LOW)

for echo in [ECHO_1, ECHO_2, ECHO_3]:
    GPIO.setup(echo, GPIO.IN)

# --- Motor Channels ---
MOTOR_FWD = 1
MOTOR_REV = 2

# --- Motor Control ---
def rotate_motor(speed):
    """Positive = forward, negative = backward"""
    duty_cycle = int(min(max(abs(speed), 0), 100) / 100 * 65535)
    if speed >= 0:
        pca.channels[MOTOR_FWD].duty_cycle = duty_cycle
        pca.channels[MOTOR_REV].duty_cycle = 0
    else:
        pca.channels[MOTOR_FWD].duty_cycle = 0
        pca.channels[MOTOR_REV].duty_cycle = duty_cycle

def stop_motor():
    pca.channels[MOTOR_FWD].duty_cycle = 0
    pca.channels[MOTOR_REV].duty_cycle = 0

# --- Servo Control ---
def set_servo_angle(angle):
    """Clamp and write angle to servo"""
    min_angle, max_angle = 50, 130
    angle = max(min_angle, min(max_angle, angle))
    pulse_min, pulse_max = 1000, 2000  # µs
    pulse = int(pulse_min + (pulse_max - pulse_min) * ((angle - min_angle) / (max_angle - min_angle)))
    pca.channels[SERVO_CHANNEL].duty_cycle = int(pulse * 65535 / 20000)

# --- Distance Measurement ---
def get_distance(trigger_pin, echo_pin):
    GPIO.output(trigger_pin, GPIO.HIGH)
    time.sleep(0.00001)
    GPIO.output(trigger_pin, GPIO.LOW)

    pulse_start, pulse_end = None, None
    timeout = time.time() + 0.02

    while GPIO.input(echo_pin) == GPIO.LOW:
        pulse_start = time.time()
        if pulse_start > timeout:
            return None

    while GPIO.input(echo_pin) == GPIO.HIGH:
        pulse_end = time.time()
        if pulse_end > timeout:
            return None

    if pulse_start and pulse_end:
        pulse_duration = pulse_end - pulse_start
        return (pulse_duration * 34300) / 2  # cm

    return None

# --- Main Loop ---
try:
    while True:
        distance_front = get_distance(TRIG_1, ECHO_1)
        distance_left = get_distance(TRIG_2, ECHO_2)
        distance_right = get_distance(TRIG_3, ECHO_3)

        # --- Corner detection ---
        if not turning and distance_front and distance_front < CORNER_TRIGGER:
            turning = True
            turns_completed += 1
            print(f"Corner detected! Turn {turns_completed} → {direction.upper()}")

            # Smooth sweeping turn
            if direction == "left":
                for angle in range(90, 50, -5):  # sweep left
                    set_servo_angle(angle)
                    rotate_motor(10)  # slower turn
                    time.sleep(0.05)
            else:
                for angle in range(90, 130, 5):  # sweep right
                    set_servo_angle(angle)
                    rotate_motor(10)
                    time.sleep(0.05)

            # Switch direction after each corner
            direction = "right" if direction == "left" else "left"
            continue

        # --- Resume straight driving after turn ---
        if turning:
            if distance_left and distance_right and distance_left < 80 and distance_right < 80:
                turning = False
                print("Re-aligned, back to centering mode")
            else:
                rotate_motor(10)  # crawl until re-aligned
                continue

        # --- Wall Following Control ---
        if distance_left and distance_right:
            # Dual-wall centering (ideal case in corridor)
            error = distance_left - distance_right
        else:
            # Fallback to single wall
            side_sensor = distance_left if direction == "left" else distance_right
            if side_sensor is None:
                print("Sensor error, skipping cycle.")
                continue
            error = TARGET_DISTANCE - side_sensor

        # PID update
        integral += error
        derivative = error - last_error
        output = KP * error + KI * integral + KD * derivative
        last_error = error

        # Servo adjustment (90 = straight ahead)
        new_angle = 90 + output
        set_servo_angle(new_angle)

        # Adaptive speed
        if distance_front and distance_front < 60:
            rotate_motor(15)   # cautious near corner
        else:
            rotate_motor(20)   # cruise

        mode = "CENTERING" if (distance_left and distance_right) else f"{direction.upper()} wall"
        print(f"Mode: {mode} | L={distance_left} cm R={distance_right} cm | "
              f"Front={distance_front} cm | Error={error:.2f} | Servo={new_angle:.1f}")

        time.sleep(0.1)

except KeyboardInterrupt:
    print("Stopping safely...")
    stop_motor()
    GPIO.cleanup()
