import threading
import time
import tkinter as tk
import csv
from collections import deque
import os
import tkinter.filedialog as fd
from datetime import datetime
import RPi.GPIO as GPIO
from board import SCL, SDA
import busio
from adafruit_pca9685 import PCA9685
import adafruit_mpu6050

BASE_DIR = os.path.dirname(os.path.abspath(__file__))

# ===============================
# CONFIGURATION VARIABLES
# ===============================
SPEED_CRUISE = 40
SERVO_CHANNEL = 0
SERVO_CENTER = 92
SERVO_MIN_ANGLE = 50
SERVO_MAX_ANGLE = 130
SERVO_PULSE_MIN = 1000
SERVO_PULSE_MAX = 2000
SERVO_PERIOD = 20000
MOTOR_FWD = 1
MOTOR_REV = 2

TRIG_FRONT, ECHO_FRONT = 22, 23
TRIG_LEFT, ECHO_LEFT = 27, 17
TRIG_RIGHT, ECHO_RIGHT = 5, 6
ULTRASONIC_TIMEOUT = 0.04
SOUND_SPEED = 17150
N_READINGS = 9
TRIG_PULSE_DURATION = 0.00001
LOOP_DELAY = 0.01
MAX_POINTS = 500

# ===============================
# HARDWARE SETUP
# ===============================
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)
i2c = busio.I2C(SCL, SDA)
pca = PCA9685(i2c)
pca.frequency = 50
mpu = adafruit_mpu6050.MPU6050(i2c)

for trig in [TRIG_FRONT, TRIG_LEFT, TRIG_RIGHT]:
    GPIO.setup(trig, GPIO.OUT)
    GPIO.output(trig, GPIO.LOW)
for echo in [ECHO_FRONT, ECHO_LEFT, ECHO_RIGHT]:
    GPIO.setup(echo, GPIO.IN)

# ===============================
# SENSOR DATA STORAGE
# ===============================
time_data = deque(maxlen=MAX_POINTS)
front_data = deque(maxlen=MAX_POINTS)
left_data = deque(maxlen=MAX_POINTS)
right_data = deque(maxlen=MAX_POINTS)
front_raw = deque(maxlen=MAX_POINTS)
left_raw = deque(maxlen=MAX_POINTS)
right_raw = deque(maxlen=MAX_POINTS)
angle_data = deque(maxlen=MAX_POINTS)
state_data = deque(maxlen=MAX_POINTS)

# ===============================
# ROBOT CONTROLLER
# ===============================
class RobotController:
    def __init__(self, pca):
        self.pca = pca
        self.servo_angle = SERVO_CENTER
        self.motor_speed = 0
        self.front_history = deque(maxlen=N_READINGS)
        self.left_history = deque(maxlen=N_READINGS)
        self.right_history = deque(maxlen=N_READINGS)

    def set_servo(self, angle):
        angle = max(SERVO_MIN_ANGLE, min(SERVO_MAX_ANGLE, angle))
        pulse = int(SERVO_PULSE_MIN + (SERVO_PULSE_MAX - SERVO_PULSE_MIN) *
                    ((angle - SERVO_MIN_ANGLE) / (SERVO_MAX_ANGLE - SERVO_MIN_ANGLE)))
        self.pca.channels[SERVO_CHANNEL].duty_cycle = int(pulse * 65535 / SERVO_PERIOD)
        self.servo_angle = angle

    def rotate_motor(self, speed):
        duty_cycle = int(min(max(abs(speed), 0), 100)/100*65535)
        if speed >= 0:
            self.pca.channels[MOTOR_FWD].duty_cycle = duty_cycle
            self.pca.channels[MOTOR_REV].duty_cycle = 0
        else:
            self.pca.channels[MOTOR_FWD].duty_cycle = 0
            self.pca.channels[MOTOR_REV].duty_cycle = duty_cycle
        self.motor_speed = speed

    def stop_motor(self):
        self.pca.channels[MOTOR_FWD].duty_cycle = 0
        self.pca.channels[MOTOR_REV].duty_cycle = 0
        self.motor_speed = 0

    def get_distance(self, trig, echo):
        try:
            GPIO.output(trig, True)
            time.sleep(TRIG_PULSE_DURATION)
            GPIO.output(trig, False)
            start = time.perf_counter()
            while GPIO.input(echo) == 0:
                if time.perf_counter() - start > ULTRASONIC_TIMEOUT:
                    return None
            pulse_start = time.perf_counter()
            while GPIO.input(echo) == 1:
                if time.perf_counter() - pulse_start > ULTRASONIC_TIMEOUT:
                    return None
            pulse_end = time.perf_counter()
            return (pulse_end - pulse_start) * SOUND_SPEED
        except:
            return None

    def filtered_distance(self, trig, echo, history):
        d = self.get_distance(trig, echo)
        history.append(d)
        valid = [x for x in history if x is not None]
        if not valid:
            return 999
        s = sorted(valid)
        mid = len(s) // 2
        median_val = (s[mid - 1] + s[mid]) / 2 if len(s) % 2 == 0 else s[mid]
        return median_val, d  # Return filtered and raw

robot = RobotController(pca)

# ===============================
# MANUAL CONTROL VARIABLES
# ===============================
turning_left = False
turning_right = False
moving_forward = False

# ===============================
# MANUAL CONTROL FUNCTIONS
# ===============================
def key_up(event=None):
    global moving_forward
    robot.rotate_motor(SPEED_CRUISE)
    moving_forward = True

def key_down(event=None):
    global moving_forward
    robot.stop_motor()
    moving_forward = False

def key_left_press(event=None):
    global turning_left
    turning_left = True

def key_left_release(event=None):
    global turning_left
    robot.set_servo(SERVO_CENTER)
    turning_left = False

def key_right_press(event=None):
    global turning_right
    turning_right = True

def key_right_release(event=None):
    global turning_right
    robot.set_servo(SERVO_CENTER)
    turning_right = False

# ===============================
# SENSOR LOOP
# ===============================
def sensor_loop():
    while True:
        current_time = time.time()
        filt_front, raw_front = robot.filtered_distance(TRIG_FRONT, ECHO_FRONT, robot.front_history)
        filt_left, raw_left = robot.filtered_distance(TRIG_LEFT, ECHO_LEFT, robot.left_history)
        filt_right, raw_right = robot.filtered_distance(TRIG_RIGHT, ECHO_RIGHT, robot.right_history)
        angle = mpu.gyro[2]

        # Update deques
        time_data.append(current_time)
        front_data.append(filt_front)
        left_data.append(filt_left)
        right_data.append(filt_right)
        front_raw.append(raw_front)
        left_raw.append(raw_left)
        right_raw.append(raw_right)
        angle_data.append(angle)
        state_data.append(f"Motor:{robot.motor_speed}, Servo:{robot.servo_angle}")

        # Apply continuous turning if keys pressed
        if turning_left:
            robot.set_servo(SERVO_CENTER - 30)
        elif turning_right:
            robot.set_servo(SERVO_CENTER + 30)
        else:
            robot.set_servo(SERVO_CENTER)

        time.sleep(LOOP_DELAY)

# ===============================
# CSV EXPORT
# ===============================
def export_data_csv():
    filename = f"manual_data_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
    with open(filename, mode='w', newline='') as file:
        writer = csv.writer(file)
        writer.writerow(["Time", 
                         "Front_Filtered", "Left_Filtered", "Right_Filtered",
                         "Front_Raw", "Left_Raw", "Right_Raw",
                         "GyroZ", "MotorSpeed", "ServoAngle"])
        for i in range(len(time_data)):
            writer.writerow([
                time_data[i],
                front_data[i], left_data[i], right_data[i],
                front_raw[i], left_raw[i], right_raw[i],
                angle_data[i],
                robot.motor_speed,
                robot.servo_angle
            ])
    print(f"âœ… Data exported to {filename}")

# ===============================
# GUI
# ===============================
def launch_gui():
    global root
    root = tk.Tk()
    root.title("Manual Robot Control + Data Logging")

    lbl_status = tk.Label(root, text="Up=Start, Down=Stop, Left/Right=Turn", font=("Arial", 16))
    lbl_status.pack(pady=20)

    btn_stop = tk.Button(root, text="STOP", command=key_down, width=20, height=2, bg="red", fg="white")
    btn_stop.pack(pady=10)

    btn_export = tk.Button(root, text="Export CSV", command=export_data_csv, width=20, height=2, bg="purple", fg="white")
    btn_export.pack(pady=10)

    # Bind keys
    root.bind("<Up>", key_up)
    root.bind("<Down>", key_down)
    root.bind("<Left>", key_left_press)
    root.bind("<KeyRelease-Left>", key_left_release)
    root.bind("<Right>", key_right_press)
    root.bind("<KeyRelease-Right>", key_right_release)

    root.mainloop()

# ===============================
# MAIN
# ===============================
if __name__ == "__main__":
    threading.Thread(target=sensor_loop, daemon=True).start()
    launch_gui()
