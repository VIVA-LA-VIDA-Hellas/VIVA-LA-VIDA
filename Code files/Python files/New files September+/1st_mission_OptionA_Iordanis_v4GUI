#----------------------------------------------------------------------------------------------------------------------
# Autonomous drive - VivaLaVida
# v4 - 23/9/2025
# v4.1 - remove camera, add logging - 24/9/2025
# v4.2 - improved turn logic and timeout slider - 24/9/2025
#
# Logic description
# - Continuously read ultrasonic sensor distances: front, left, and right.
# - Emergency stop: If front distance < stop threshold, halt immediately to prevent collisions.
# - Initiate turn:
#     Triggered when front distance < configured turn trigger.
#     Robot chooses the side with the greater distance (left or right) to turn toward.
#     Moves forward while steering to avoid the obstacle.
#     Turn ends when front sensor reads clear OR timeout reached.
# - PID wall-following:
#     Compares left and right distances to maintain a centered path between walls.
#     Adjusts servo angle based on PID output to correct robot heading.
#     Applies a deadzone to ignore small deviations and prevent oscillations.
#     Uses adaptive PID gains to respond more aggressively to larger errors.
# - Continuous forward motion: Robot moves at configured cruise speed unless turning or stopped.
# - Integrates real-time sensor input, PID steering, and turning logic for autonomous navigation and obstacle avoidance.
#-----------------------------------------------------------------------------------------------------------------------

# ===============================
# IMPORTS: All modules used in this script are imported here.
# ===============================
import tkinter as tk                          # Tkinter for GUI windows
from tkinter import ttk                       # Tkinter themed widgets
import matplotlib.pyplot as plt               # For plotting sensor and control graphs
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg  # Embedding matplotlib plots in Tkinter
import threading                              # To run robot control loop in background
import time                                   # For time tracking, delays, and sensor timing
import RPi.GPIO as GPIO                       # Raspberry Pi GPIO for hardware control
from board import SCL, SDA                    # Board module for I2C pins
import busio                                  # I2C communication setup
from adafruit_pca9685 import PCA9685          # Servo/motor driver for PWM output
from collections import deque                 # Double-ended queue for sliding window of sensor values
# import logging                                # For message logging and debugging

# ===============================
# LOGGING SETUP: Configures logging for info and warnings.
# ===============================
# logging.basicConfig(level=logging.INFO)       # Enable info-level logging to console

# ===============================
# CONFIGURABLE VARIABLES: Robot operating parameters and control settings.
# ===============================
TARGET_DISTANCE = 30                          # Desired wall distance for PID wall-following (cm)
FRONT_TURN_TRIGGER = 90                       # Distance to trigger a turn (cm)
STOP_THRESHOLD = 20                           # Minimum front distance before emergency stop (cm)
CROSSOVER_THRESHOLD = 30                      # Additional distance to end a turn (cm)
SPEED_CRUISE = 20                             # Normal driving speed (0-100)
SPEED_TURN = 10                               # Reduced speed during turning (0-100)
TURN_ANGLE_LEFT = 80                          # Servo angle for left turn (degrees)
TURN_ANGLE_RIGHT = 100                        # Servo angle for right turn (degrees)
SERVO_CENTER = 90                             # Servo center angle (straight ahead, degrees)
SERVO_MIN_ANGLE = 50                          # Minimum allowed servo angle
SERVO_MAX_ANGLE = 130                         # Maximum allowed servo angle
KP, KI, KD = 1, 0, 2                          # PID controller constants
DEADZONE = 2                                  # Range near zero error for no correction (degrees)
MAX_LAPS = 3                                  # Maximum laps to complete (if using lap logic)
N_READINGS = 5                                # Number of readings for median filter (sensor smoothing)
TURN_TIMEOUT = 1.0                            # Maximum allowed time for a turn (seconds)

# ===============================
# HARDWARE SETUP: GPIO, I2C, PCA9685 driver and sensor pin configuration.
# ===============================
GPIO.setmode(GPIO.BCM)                        # Use Broadcom SOC channel numbering
GPIO.setwarnings(False)                       # Suppress GPIO warnings on repeated runs
i2c = busio.I2C(SCL, SDA)                     # Create I2C bus interface using board pins
pca = PCA9685(i2c)                            # Instantiate PCA9685 PWM driver via I2C
pca.frequency = 50                            # Set PWM frequency for servo/motor

SERVO_CHANNEL = 0                             # PCA9685 channel for steering servo
MOTOR_FWD = 1                                 # PCA9685 channel for forward motor
MOTOR_REV = 2                                 # PCA9685 channel for reverse motor

TRIG_FRONT, ECHO_FRONT = 22, 23               # GPIO pins for front ultrasonic sensor
TRIG_LEFT, ECHO_LEFT = 5, 6                 # GPIO pins for left ultrasonic sensor
TRIG_RIGHT, ECHO_RIGHT = 27, 17                 # GPIO pins for right ultrasonic sensor

for trig in [TRIG_FRONT, TRIG_LEFT, TRIG_RIGHT]: # Set all trigger pins as OUTPUT
    GPIO.setup(trig, GPIO.OUT)
    GPIO.output(trig, GPIO.LOW)

for echo in [ECHO_FRONT, ECHO_LEFT, ECHO_RIGHT]: # Set all echo pins as INPUT
    GPIO.setup(echo, GPIO.IN)

# ===============================
# TKINTER GUI SETUP: Main window and variables panel.
# ===============================
root = tk.Tk()                                # Create main Tk window
root.title("Robot Control Panel")              # Set window title

var_frame = ttk.LabelFrame(root, text="Variables") # Frame for control variables
var_frame.grid(row=0, column=0, padx=5, pady=5, sticky="nw")

# Dictionary of robot variables, range, and type for dynamic sliders
variables = {
    "TARGET_DISTANCE": [TARGET_DISTANCE, 10, 50, "int"],
    "FRONT_TURN_TRIGGER": [FRONT_TURN_TRIGGER, 50, 150, "int"],
    "STOP_THRESHOLD": [STOP_THRESHOLD, 10, 30, "int"],
    "CROSSOVER_THRESHOLD": [CROSSOVER_THRESHOLD, 10, 100, "int"],
    "SPEED_CRUISE": [SPEED_CRUISE, 5, 50, "int"],
    "SPEED_TURN": [SPEED_TURN, 5, 30, "int"],
    "TURN_ANGLE_LEFT": [TURN_ANGLE_LEFT, 45, 90, "int"],
    "TURN_ANGLE_RIGHT": [TURN_ANGLE_RIGHT, 90, 135, "int"],
    "SERVO_CENTER": [SERVO_CENTER, 50, 130, "int"],
    "SERVO_MIN_ANGLE": [SERVO_MIN_ANGLE, 0, 90, "int"],
    "SERVO_MAX_ANGLE": [SERVO_MAX_ANGLE, 90, 180, "int"],
    "KP": [KP, 0, 5, "float"],
    "KI": [KI, 0, 5, "float"],
    "KD": [KD, 0, 5, "float"],
    "DEADZONE": [DEADZONE, 0, 10, "int"],
    "MAX_LAPS": [MAX_LAPS, 1, 20, "int"],
    "TURN_TIMEOUT": [TURN_TIMEOUT, 0.2, 5.0, "float"],  # Timeout slider for turns
}

slider_vars = {}                              # Dictionary of Tkinter variable objects for sliders
row = 0                                       # Row counter for grid layout
for name, (val, mn, mx, vtype) in variables.items():    # Loop through variables for slider creation
    ttk.Label(var_frame, text=name).grid(row=row, column=0, sticky="w")    # Name label
    if vtype == "int":
        slider_var = tk.IntVar(value=val)     # Integer variable for slider
        slider = ttk.Scale(var_frame, from_=mn, to=mx, variable=slider_var, orient=tk.HORIZONTAL, length=150)
    else:  # "float"
        slider_var = tk.DoubleVar(value=val)  # Float variable for slider
        def round_value(val, var=slider_var): # Rounds float slider values for display
            var.set(round(float(val), 2))
        slider = ttk.Scale(var_frame, from_=mn, to=mx, variable=slider_var, orient=tk.HORIZONTAL, length=150, command=round_value)
    slider.grid(row=row, column=1, sticky="w")    # Place slider
    ttk.Label(var_frame, textvariable=slider_var, width=7).grid(row=row, column=2) # Value label
    slider_vars[name] = slider_var                  # Store variable for later reference
    row += 1

# ===============================
# CONTROL BUTTONS: Functions and widgets for robot state control.
# ===============================
reading_flag = False                            # Sensor reading mode flag
loop_flag = False                               # Main robot loop running flag
paused_flag = False                             # Loop paused flag

def start_reading():
    """Start background sensor reading mode."""
    global reading_flag
    reading_flag = True
    update_control_buttons()

def start_loop():
    """Start robot main control loop."""
    global loop_flag, paused_flag
    loop_flag = True
    paused_flag = False
    update_control_buttons()

def pause_loop():
    """Pause robot control loop."""
    global paused_flag
    paused_flag = True
    update_control_buttons()

def resume_loop():
    """Resume robot control loop after pause."""
    global paused_flag
    paused_flag = False
    update_control_buttons()

def stop_robot():
    """Stop robot, sensor reading, and all motors."""
    global reading_flag, loop_flag, paused_flag
    reading_flag = False
    loop_flag = False
    paused_flag = False
    robot.stop_motor()
    update_control_buttons()

def update_control_buttons():
    """Update button states based on flags."""
    if reading_flag:
        start_read_button.config(state="disabled")
    else:
        start_read_button.config(state="normal")
    if loop_flag and not paused_flag:
        start_loop_button.config(state="disabled")
        pause_button.config(state="normal")
        resume_button.config(state="disabled")
    elif loop_flag and paused_flag:
        start_loop_button.config(state="disabled")
        pause_button.config(state="disabled")
        resume_button.config(state="normal")
    else:
        start_loop_button.config(state="normal")
        pause_button.config(state="disabled")
        resume_button.config(state="disabled")

# Create Tkinter buttons for robot state control and place on grid
start_read_button = ttk.Button(root, text="Start Reading", command=start_reading)
start_read_button.grid(row=1, column=0, pady=5)
start_loop_button = ttk.Button(root, text="Start Loop", command=start_loop)
start_loop_button.grid(row=2, column=0, pady=5)
pause_button = ttk.Button(root, text="Pause Loop", command=pause_loop, state="disabled")
pause_button.grid(row=3, column=0, pady=5)
resume_button = ttk.Button(root, text="Resume Loop", command=resume_loop, state="disabled")
resume_button.grid(row=4, column=0, pady=5)
stop_button = ttk.Button(root, text="Stop", command=stop_robot)
stop_button.grid(row=5, column=0, pady=5)

# ===============================
# MATPLOTLIB PLOTS: Create sensor and control feedback graphs.
# ===============================
fig, (ax_front, ax_side) = plt.subplots(2, 1, figsize=(6, 6))   # Two stacked axes for sensor plots
fig.tight_layout(pad=3.0)                       # Adjust plot spacing

ax_front.set_ylim(0, 350)                        # Set y-axis range for front sensor plot
ax_front.grid(True)                              # Show gridlines
ax_front.set_title("Front Sensor")               # Title for front sensor plot
front_line, = ax_front.plot([], [], color="blue")# Line object for updating front sensor data

ax_side.set_ylim(-150, 150)                      # Symmetrical y-axis for left/right sensors
ax_side.grid(True)                               # Show gridlines
ax_side.set_title("Left vs Right Sensors (Mirrored)") # Title for side sensor plot
ax_side.axhline(0, color="black", linewidth=1)   # Draw center line (zero)

left_line, = ax_side.plot([], [], color="green") # Line object for left sensor data
right_line, = ax_side.plot([], [], color="orange")# Line object for right sensor data

canvas = FigureCanvasTkAgg(fig, master=root)     # Embed matplotlib figure in Tkinter
canvas.get_tk_widget().grid(row=0, column=1, rowspan=7, padx=10, pady=5)

# ===============================
# DATA STORAGE FOR PLOTTING: Arrays to store time and sensor values for real-time graphs.
# ===============================
time_data = []                                  # Time steps for plotting
front_data, left_data, right_data = [], [], []  # Sensor data for plotting

def update_ui_plots():
    """Update all UI plots from latest data and redraw canvas."""
    # Remove old fills before drawing new ones
    for coll in list(ax_front.collections):
        coll.remove()
    for coll in list(ax_side.collections):
        coll.remove()

    # Dynamic fill for front sensor (green/yellow/red based on distance)
    if front_data:
        front_color = "green"
        if front_data[-1] < 50:
            front_color = "red"
        elif front_data[-1] < 100:
            front_color = "yellow"
        ax_front.fill_between(time_data, 0, front_data, color=front_color, alpha=0.5)
        front_line.set_data(time_data, front_data)

    # Dynamic fill for left sensor (green/yellow/red)
    if left_data:
        left_color = "green"
        if left_data[-1] < 50:
            left_color = "red"
        elif left_data[-1] < 100:
            left_color = "yellow"
        ax_side.fill_between(time_data, 0, left_data, color=left_color, alpha=0.5)
        left_line.set_data(time_data, left_data)

    # Dynamic fill for right sensor (mirrored negative side, green/yellow/red)
    if right_data:
        right_color = "green"
        if right_data[-1] < 50:
            right_color = "red"
        elif right_data[-1] < 100:
            right_color = "yellow"
        ax_side.fill_between(time_data, 0, [-v for v in right_data], color=right_color, alpha=0.5)
        right_line.set_data(time_data, [-v for v in right_data])

    # Set x-axis limits to show last 100 readings
    ax_front.set_xlim(max(0, len(time_data)-100), len(time_data))
    ax_side.set_xlim(max(0, len(time_data)-100), len(time_data))

    canvas.draw()                               # Redraw the canvas
    try:
        canvas.flush_events()                   # Flush if possible (for real-time update)
    except Exception:
        pass

# ===============================
# ROBOT CONTROL CLASS: Methods for servo, motor, sensor, PID, and turn logic.
# ===============================
class RobotController:
    def __init__(self, pca, slider_vars):
        """Initialize controller with PCA9685 driver and variable sliders."""
        self.pca = pca
        self.slider_vars = slider_vars
        self.integral = 0                      # PID integral term
        self.last_error = 0                    # Last PID error (for derivative)
        self.front_history = deque(maxlen=N_READINGS)  # Front sensor value history
        self.left_history = deque(maxlen=N_READINGS)   # Left sensor value history
        self.right_history = deque(maxlen=N_READINGS)  # Right sensor value history

    def set_servo(self, angle):
        """Set servo to specified angle, clamped within min/max range."""
        min_angle = self.slider_vars["SERVO_MIN_ANGLE"].get()
        max_angle = self.slider_vars["SERVO_MAX_ANGLE"].get()
        angle = max(min_angle, min(max_angle, angle)) # Clamp angle
        # Convert angle to pulse width (1000-2000us typical)
        pulse = int(1000 + (2000 - 1000) * ((angle - min_angle) / (max_angle - min_angle)))
        self.pca.channels[SERVO_CHANNEL].duty_cycle = int(pulse * 65535 / 20000) # Set PWM

    def rotate_motor(self, speed):
        """Set motor speed/direction: positive for forward, negative for reverse."""
        duty_cycle = int(min(max(abs(speed), 0), 100) / 100 * 65535) # Scale to PWM range
        if speed >= 0:
            self.pca.channels[MOTOR_FWD].duty_cycle = duty_cycle
            self.pca.channels[MOTOR_REV].duty_cycle = 0
        else:
            self.pca.channels[MOTOR_FWD].duty_cycle = 0
            self.pca.channels[MOTOR_REV].duty_cycle = duty_cycle

    def stop_motor(self):
        """Stop motors by setting both channels to zero PWM."""
        self.pca.channels[MOTOR_FWD].duty_cycle = 0
        self.pca.channels[MOTOR_REV].duty_cycle = 0

    def get_distance(self, trigger, echo):
        """Read distance from ultrasonic sensor using trigger/echo pins."""
        try:
            GPIO.output(trigger, GPIO.HIGH)
            time.sleep(0.00001)
            GPIO.output(trigger, GPIO.LOW)
            pulse_start, pulse_end = None, None
            timeout = time.time() + 0.02
            while GPIO.input(echo) == GPIO.LOW and time.time() < timeout:
                pulse_start = time.time()
            timeout = time.time() + 0.02
            while GPIO.input(echo) == GPIO.HIGH and time.time() < timeout:
                pulse_end = time.time()
            if pulse_start and pulse_end:
                return (pulse_end - pulse_start) * 17150 # Convert time to cm
            return None
        except Exception as e:
            logging.error(f"Sensor read failed: {e}")
            return None

    def filtered_distance(self, trigger, echo, history):
        """Return median of recent sensor readings for noise reduction."""
        d = self.get_distance(trigger, echo)
        if d is not None:
            history.append(d)
        if history:
            sorted_hist = sorted(history)
            mid = len(sorted_hist) // 2
            if len(sorted_hist) % 2 == 0:
                return (sorted_hist[mid-1] + sorted_hist[mid]) / 2
            else:
                return sorted_hist[mid]
        return None

    def pid_control(self, d_left, d_right):
        """Calculate PID steering correction based on left/right distance error."""
        error = 0
        if d_left is not None and d_right is not None:
            error = d_left - d_right
        elif d_left is not None:
            error = self.slider_vars["TARGET_DISTANCE"].get() - d_left
        elif d_right is not None:
            error = d_right - self.slider_vars["TARGET_DISTANCE"].get()
        self.integral += error
        self.integral = max(min(self.integral, 100), -100)  # Clamp integral against windup
        derivative = error - self.last_error
        self.last_error = error
        if abs(error) > 20:
            kp, kd = 1.5, 3.0
        else:
            kp, kd = 0.7, 1.5
        output = kp * error + kd * derivative
        if abs(error) < self.slider_vars["DEADZONE"].get():
            output = 0
        return output

    def turn_decision(self, d_left, d_right):
        """Decide which direction to turn (LEFT or RIGHT) based on sensor readings."""
        if d_left is not None and d_right is not None:
            if d_left > d_right:
                return "LEFT"
            else:
                return "RIGHT"
        elif d_left is not None:
            return "LEFT"
        elif d_right is not None:
            return "RIGHT"
        logging.warning("Both side sensors unavailable, defaulting to LEFT turn.")
        return "LEFT"

robot = RobotController(pca, slider_vars)      # Instantiate robot control class

# ===============================
# ROBOT LOOP THREAD: Main logic for autonomous navigation and sensor data collection.
# ===============================
def robot_loop():
    """Background thread that runs robot logic and updates sensor data."""
    t = 0
    turning = False
    turn_start_distance = None
    turn_start_time = None
    d_front = d_left = d_right = None
    while True:
        if reading_flag:
            # Read and filter sensor values for all sides
            d_front = robot.filtered_distance(TRIG_FRONT, ECHO_FRONT, robot.front_history)
            d_left = robot.filtered_distance(TRIG_LEFT, ECHO_LEFT, robot.left_history)
            d_right = robot.filtered_distance(TRIG_RIGHT, ECHO_RIGHT, robot.right_history)
            # Append sensor data for plotting
            time_data.append(t)
            front_data.append(d_front or 0)
            left_data.append(d_left or 0)
            right_data.append(d_right or 0)
            # Keep only last 100 data points for plotting
            if len(time_data) > 100:
                time_data.pop(0)
                front_data.pop(0)
                left_data.pop(0)
                right_data.pop(0)
            # Batch plot updates every 10 ticks
            if t % 10 == 0:
                root.after(0, update_ui_plots)
            t += 1

        if loop_flag and not paused_flag:
            # EMERGENCY STOP: If front sensor too close, stop immediately
            if d_front is not None and d_front < slider_vars["STOP_THRESHOLD"].get():
                robot.stop_motor()
                logging.warning("EMERGENCY STOP: Front sensor too close!")
                time.sleep(0.05)
                continue

            # TURNING LOGIC: If in turning state, continue turn until clear or timeout
            if turning:
                robot.rotate_motor(slider_vars["SPEED_TURN"].get())
                turn_timeout = slider_vars["TURN_TIMEOUT"].get()
                if ((d_front is not None and turn_start_distance is not None and d_front > turn_start_distance + slider_vars["CROSSOVER_THRESHOLD"].get())
                    or (turn_start_time is not None and time.time() - turn_start_time > turn_timeout)):
                    robot.stop_motor()
                    robot.set_servo(slider_vars["SERVO_CENTER"].get())
                    turning = False
                    turn_start_time = None
                    print("Turn ended: front_distance=%s, time=%s", d_front, time.time() - (turn_start_time or 0))
                time.sleep(0.05)
                continue

            # TURN INITIATION: If obstacle detected, choose turn direction and initiate turn
            if d_front is not None and d_front < slider_vars["FRONT_TURN_TRIGGER"].get():
                direction = robot.turn_decision(d_left, d_right)
                angle_var = f"TURN_ANGLE_{direction}"
                robot.set_servo(slider_vars[angle_var].get())
                turn_start_distance = d_front or 0
                turning = True
                turn_start_time = time.time()
                robot.rotate_motor(slider_vars["SPEED_TURN"].get())
                print("Turn started: direction=%s, front_distance=%s", direction, d_front)
                time.sleep(0.05)
                continue

            # PID WALL FOLLOWING: Calculate correction and drive forward
            output = robot.pid_control(d_left, d_right)
            new_angle = slider_vars["SERVO_CENTER"].get() + output
            servo_min = slider_vars["SERVO_MIN_ANGLE"].get()
            servo_max = slider_vars["SERVO_MAX_ANGLE"].get()
            new_angle = max(servo_min, min(servo_max, new_angle)) # Clamp to servo range
            robot.set_servo(new_angle)
            robot.rotate_motor(slider_vars["SPEED_CRUISE"].get())
        time.sleep(0.05)

threading.Thread(target=robot_loop, daemon=True).start() # Start robot loop thread

# ===============================
# EXIT HANDLER FOR CLEANUP: Run on window close for safe GPIO shutdown.
# ===============================
def on_closing():
    """Shutdown motors and clean up GPIO before exit."""
    try:
        robot.stop_motor()
        GPIO.cleanup()
    except Exception as e:
        logging.error(f"Cleanup failed: {e}")
    root.destroy()

root.protocol("WM_DELETE_WINDOW", on_closing)  # Register exit handler

# ===============================
# START TKINTER MAINLOOP: Run the GUI event loop.
# ===============================
root.mainloop()                               # Start GUI
