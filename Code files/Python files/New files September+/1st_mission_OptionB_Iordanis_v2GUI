# ==============================
# FULL ROBOT CONTROL GUI (PID + Manual + Sliders + Graph)
# ==============================

import time
import threading
import tkinter as tk
from tkinter import ttk
import RPi.GPIO as GPIO
from board import SCL, SDA
import busio
from adafruit_pca9685 import PCA9685
import matplotlib
matplotlib.use("TkAgg")
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

# ==============================
# CONFIGURATION VARIABLES
# ==============================
LOOP_DELAY = 0.1                              # Main loop delay (s)
START_DELAY = 2                               # Delay before initializing hardware
TARGET_DISTANCE = 50.0                         # Desired wall distance for PID
KP, KI, KD = 1.0, 0.0, 0.8                   # PID constants
SERVO_CHANNEL = 0                             # Servo channel on PCA9685
SERVO_MIN_ANGLE, SERVO_MAX_ANGLE = 50, 130   # Servo min/max angles
SERVO_CENTER = 90                              # Servo center
MOTOR_FWD, MOTOR_REV = 1, 2                   # PCA9685 motor channels
SPEED_CRUISE, SPEED_SLOW, TURN_SPEED = 20, 15, 10  # Speeds
TURN_TRIGGER_DISTANCE = 90                     # Front distance to trigger turn
TURN_OPEN_THRESHOLD = 100                      # Side distance to choose turn
BASE_TURN_TIME = 0.8                           # Time for 90-degree turn
BASE_SPEED = 10                                # Reference speed for turn duration
MAX_LAPS = 3                                   # Maximum laps
EMERGENCY_STOP_DISTANCE = 5                    # Stop immediately if front < 5 cm
TRIG_FRONT, ECHO_FRONT = 22, 23
TRIG_LEFT, ECHO_LEFT = 27, 17
TRIG_RIGHT, ECHO_RIGHT = 5, 6

# ==============================
# GLOBAL STATE
# ==============================
robot_running = False                          # True if robot loop active
auto_mode = True                               # PID auto mode
sensor_data = {"front":0,"left":0,"right":0}  # Sensor readings
turns_completed = 0
laps_completed = 0
direction = "left"
integral = 0
last_error = 0

# ==============================
# HARDWARE INITIALIZATION
# ==============================
time.sleep(START_DELAY)
i2c = busio.I2C(SCL,SDA)
pca = PCA9685(i2c)
pca.frequency = 50

GPIO.setmode(GPIO.BCM)
for trig in [TRIG_FRONT, TRIG_LEFT, TRIG_RIGHT]:
    GPIO.setup(trig, GPIO.OUT)
    GPIO.output(trig, GPIO.LOW)
for echo in [ECHO_FRONT,ECHO_LEFT,ECHO_RIGHT]:
    GPIO.setup(echo, GPIO.IN)

# ==============================
# HELPER FUNCTIONS
# ==============================
def rotate_motor(speed):
    duty_cycle = int(min(max(abs(speed),0),100)/100*65535)
    if speed>=0:
        pca.channels[MOTOR_FWD].duty_cycle=duty_cycle
        pca.channels[MOTOR_REV].duty_cycle=0
    else:
        pca.channels[MOTOR_FWD].duty_cycle=0
        pca.channels[MOTOR_REV].duty_cycle=duty_cycle

def stop_motor():
    pca.channels[MOTOR_FWD].duty_cycle=0
    pca.channels[MOTOR_REV].duty_cycle=0

def set_servo_angle(angle):
    angle=max(SERVO_MIN_ANGLE,min(SERVO_MAX_ANGLE,angle))
    pulse_min,pulse_max=1000,2000
    pulse=int(pulse_min+(pulse_max-pulse_min)*((angle-SERVO_MIN_ANGLE)/(SERVO_MAX_ANGLE-SERVO_MIN_ANGLE)))
    pca.channels[SERVO_CHANNEL].duty_cycle=int(pulse*65535/20000)

def get_distance(trigger,echo):
    GPIO.output(trigger,GPIO.HIGH)
    time.sleep(0.00001)
    GPIO.output(trigger,GPIO.LOW)
    pulse_start,pulse_end=None,None
    timeout=time.time()+0.02
    while GPIO.input(echo)==GPIO.LOW:
        pulse_start=time.time()
        if pulse_start>timeout: return None
    timeout=time.time()+0.02
    while GPIO.input(echo)==GPIO.HIGH:
        pulse_end=time.time()
        if pulse_end>timeout: return None
    if pulse_start and pulse_end:
        return (pulse_end-pulse_start)*34300/2
    return None

# ==============================
# ROBOT LOOP
# ==============================
def robot_loop():
    global sensor_data, turns_completed, laps_completed, direction
    global integral, last_error, robot_running, auto_mode

    while robot_running:
        distance_front = get_distance(TRIG_FRONT,ECHO_FRONT)
        distance_left  = get_distance(TRIG_LEFT,ECHO_LEFT)
        distance_right = get_distance(TRIG_RIGHT,ECHO_RIGHT)
        sensor_data["front"]=distance_front or 0
        sensor_data["left"]=distance_left or 0
        sensor_data["right"]=distance_right or 0

        # Emergency stop
        if distance_front and distance_front<EMERGENCY_STOP_DISTANCE:
            print("EMERGENCY STOP")
            stop_motor()
            robot_running=False
            break

        if auto_mode:
            # Check front and turn if blocked
            if distance_front and distance_front<TURN_TRIGGER_DISTANCE:
                if distance_left and distance_left>TURN_OPEN_THRESHOLD:
                    direction="left"
                elif distance_right and distance_right>TURN_OPEN_THRESHOLD:
                    direction="right"
                else:
                    direction="left" if (distance_left or 0)>(distance_right or 0) else "right"
                turn_duration=BASE_TURN_TIME*(BASE_SPEED/TURN_SPEED)
                if direction=="left": set_servo_angle(SERVO_MIN_ANGLE)
                else: set_servo_angle(SERVO_MAX_ANGLE)
                rotate_motor(TURN_SPEED)
                time.sleep(turn_duration)
                stop_motor()
                set_servo_angle(SERVO_CENTER)
                time.sleep(0.2)
                turns_completed+=1
                if turns_completed>=4:
                    turns_completed=0
                    laps_completed+=1
                continue

            # PID wall-following
            if distance_left and distance_right:
                error=distance_left-distance_right
            else:
                side_sensor=distance_left if direction=="left" else distance_right
                if side_sensor is None: continue
                error=TARGET_DISTANCE-side_sensor
            integral+=error
            derivative=error-last_error
            output=KP*error+KI*integral+KD*derivative
            last_error=error
            set_servo_angle(SERVO_CENTER+output)
            if distance_front and distance_front<60:
                rotate_motor(SPEED_SLOW)
            else:
                rotate_motor(SPEED_CRUISE)

        time.sleep(LOOP_DELAY)

# ==============================
# MANUAL FUNCTIONS
# ==============================
def manual_turn_left():
    if robot_running:
        set_servo_angle(SERVO_MIN_ANGLE)
        rotate_motor(TURN_SPEED)
        time.sleep(BASE_TURN_TIME)
        stop_motor()
        set_servo_angle(SERVO_CENTER)

def manual_turn_right():
    if robot_running:
        set_servo_angle(SERVO_MAX_ANGLE)
        rotate_motor(TURN_SPEED)
        time.sleep(BASE_TURN_TIME)
        stop_motor()
        set_servo_angle(SERVO_CENTER)

def reset_laps():
    global laps_completed, turns_completed
    laps_completed=0
    turns_completed=0
    print("Laps reset")

def toggle_auto_mode():
    global auto_mode
    auto_mode=not auto_mode
    print(f"Auto mode: {auto_mode}")

def emergency_stop():
    global robot_running
    robot_running=False
    stop_motor()

# ==============================
# GUI INITIALIZATION
# ==============================
root=tk.Tk()
root.title("Robot Control Panel")

# Robot control buttons
robot_frame=ttk.LabelFrame(root,text="Robot Control")
robot_frame.pack(padx=10,pady=5)
ttk.Button(robot_frame,text="START",command=lambda:start_thread()).pack(side="left",padx=5,pady=5)
ttk.Button(robot_frame,text="STOP",command=emergency_stop).pack(side="left",padx=5,pady=5)
ttk.Button(robot_frame,text="Reset Laps",command=reset_laps).pack(side="left",padx=5,pady=5)
ttk.Button(robot_frame,text="Toggle Auto Mode",command=toggle_auto_mode).pack(side="left",padx=5,pady=5)

# Manual turn buttons
manual_frame=ttk.LabelFrame(root,text="Manual Turn")
manual_frame.pack(padx=10,pady=5)
ttk.Button(manual_frame,text="Turn LEFT",command=manual_turn_left).pack(side="left",padx=5,pady=5)
ttk.Button(manual_frame,text="Turn RIGHT",command=manual_turn_right).pack(side="left",padx=5,pady=5)

# ==============================
# Manual servo & motor sliders
# ==============================
slider_frame=ttk.LabelFrame(root,text="Manual Servo & Motor Control")
slider_frame.pack(padx=10,pady=5)
servo_slider=tk.Scale(slider_frame,from_=SERVO_MIN_ANGLE,to=SERVO_MAX_ANGLE,
                      orient=tk.HORIZONTAL,length=300,label="Servo Angle")
servo_slider.set(SERVO_CENTER)
servo_slider.pack(padx=5,pady=5)

motor_slider=tk.Scale(slider_frame,from_=-100,to=100,
                      orient=tk.HORIZONTAL,length=300,label="Motor Speed")
motor_slider.set(0)
motor_slider.pack(padx=5,pady=5)

def update_servo_from_slider(val):
    set_servo_angle(float(val))
def update_motor_from_slider(val):
    rotate_motor(float(val))
servo_slider.config(command=update_servo_from_slider)
motor_slider.config(command=update_motor_from_slider)
def slider_override(event=None):
    global auto_mode
    auto_mode=False
servo_slider.bind("<ButtonPress-1>",slider_override)
motor_slider.bind("<ButtonPress-1>",slider_override)

# ==============================
# Sensor labels
# ==============================
label_frame = ttk.LabelFrame(root,text="Sensors (cm)")
label_frame.pack(padx=10,pady=5)
front_label=ttk.Label(label_frame,text="Front:0"); front_label.pack()
left_label=ttk.Label(label_frame,text="Left:0"); left_label.pack()
right_label=ttk.Label(label_frame,text="Right:0"); right_label.pack()
laps_label=ttk.Label(root,text="Laps:0"); laps_label.pack()

# ==============================
# Live sensor graph
# ==============================
fig=Figure(figsize=(6,3))
ax=fig.add_subplot(111)
ax.set_ylim(0,250)
line_front,=ax.plot([],[],label="Front",color="red")
line_left,=ax.plot([],[],label="Left",color="blue")
line_right,=ax.plot([],[],label="Right",color="green")
ax.legend()
canvas=FigureCanvasTkAgg(fig,master=root)
canvas.get_tk_widget().pack()

plot_length=50
time_data=[]
front_data,left_data,right_data=[],[],[]

def update_gui():
    t=time.strftime("%H:%M:%S")
    time_data.append(t)
    front_data.append(sensor_data["front"])
    left_data.append(sensor_data["left"])
    right_data.append(sensor_data["right"])
    if len(time_data)>plot_length:
        time_data.pop(0); front_data.pop(0); left_data.pop(0); right_data.pop(0)
    line_front.set_data(range(len(front_data)),front_data)
    line_left.set_data(range(len(left_data)),left_data)
    line_right.set_data(range(len(right_data)),right_data)
    ax.set_xlim(0,plot_length)
    canvas.draw()
    front_label.config(text=f"Front:{sensor_data['front']:.1f}")
    left_label.config(text=f"Left:{sensor_data['left']:.1f}")
    right_label.config(text=f"Right:{sensor_data['right']:.1f}")
    laps_label.config(text=f"Laps:{laps_completed}")
    root.after(100,update_gui)

# ==============================
# Arrow key manual control
# ==============================
down_press_time=None
backward_active=False
MANUAL_SPEED_FORWARD=SPEED_CRUISE
MANUAL_SPEED_BACKWARD=-SPEED_CRUISE

def on_up_press(event):
    global auto_mode
    auto_mode=False
    rotate_motor(MANUAL_SPEED_FORWARD)
def on_up_release(event): pass

def on_down_press(event):
    global down_press_time, backward_active, auto_mode
    auto_mode=False
    down_press_time=time.time()
    backward_active=False

def on_down_release(event):
    global down_press_time, backward_active
    press_duration=time.time()-down_press_time
    if press_duration<1.0:
        stop_motor()
        backward_active=False
    elif backward_active:
        stop_motor()
        backward_active=False

def check_down_hold():
    global down_press_time, backward_active
    if down_press_time is None: return
    if not backward_active and (time.time()-down_press_time)>=1.0:
        rotate_motor(MANUAL_SPEED_BACKWARD)
        backward_active=True
    root.after(100,check_down_hold)

root.bind("<KeyPress-Up>",on_up_press)
root.bind("<KeyRelease-Up>",on_up_release)
root.bind("<KeyPress-Down>",on_down_press)
root.bind("<KeyRelease-Down>",on_down_release)
check_down_hold()

# ==============================
# CONFIGURATION SLIDERS (PID, Speeds, Servo angles, Turn time)
# ==============================
config_frame = ttk.LabelFrame(root, text="Adjustable Variables")
config_frame.pack(padx=10, pady=5, fill="x")

# PID sliders
kp_slider = tk.Scale(config_frame, from_=0, to=5, resolution=0.1, orient=tk.HORIZONTAL,
                     label="KP", length=250, command=lambda v: globals().update(KP=float(v)))
kp_slider.set(KP); kp_slider.pack(padx=5,pady=2)

ki_slider = tk.Scale(config_frame, from_=0, to=1, resolution=0.01, orient=tk.HORIZONTAL,
                     label="KI", length=250, command=lambda v: globals().update(KI=float(v)))
ki_slider.set(KI); ki_slider.pack(padx=5,pady=2)

kd_slider = tk.Scale(config_frame, from_=0, to=5, resolution=0.1, orient=tk.HORIZONTAL,
                     label="KD", length=250, command=lambda v: globals().update(KD=float(v)))
kd_slider.set(KD); kd_slider.pack(padx=5,pady=2)

# Target distance
target_slider = tk.Scale(config_frame, from_=10, to=100, resolution=1, orient=tk.HORIZONTAL,
                         label="Target Distance", length=250,
                         command=lambda v: globals().update(TARGET_DISTANCE=float(v)))
target_slider.set(TARGET_DISTANCE); target_slider.pack(padx=5,pady=2)

# Speeds
speed_cruise_slider = tk.Scale(config_frame, from_=0, to=50, resolution=1, orient=tk.HORIZONTAL,
                               label="Cruise Speed", length=250,
                               command=lambda v: globals().update(SPEED_CRUISE=float(v)))
speed_cruise_slider.set(SPEED_CRUISE); speed_cruise_slider.pack(padx=5,pady=2)

speed_slow_slider = tk.Scale(config_frame, from_=0, to=50, resolution=1, orient=tk.HORIZONTAL,
                             label="Slow Speed", length=250,
                             command=lambda v: globals().update(SPEED_SLOW=float(v)))
speed_slow_slider.set(SPEED_SLOW); speed_slow_slider.pack(padx=5,pady=2)

turn_speed_slider = tk.Scale(config_frame, from_=0, to=50, resolution=1, orient=tk.HORIZONTAL,
                             label="Turn Speed", length=250,
                             command=lambda v: globals().update(TURN_SPEED=float(v)))
turn_speed_slider.set(TURN_SPEED); turn_speed_slider.pack(padx=5,pady=2)

# Servo angles
servo_min_slider = tk.Scale(config_frame, from_=0, to=180, resolution=1, orient=tk.HORIZONTAL,
                            label="Servo Min Angle", length=250,
                            command=lambda v: globals().update(SERVO_MIN_ANGLE=float(v)))
servo_min_slider.set(SERVO_MIN_ANGLE); servo_min_slider.pack(padx=5,pady=2)

servo_max_slider = tk.Scale(config_frame, from_=0, to=180, resolution=1, orient=tk.HORIZONTAL,
                            label="Servo Max Angle", length=250,
                            command=lambda v: globals().update(SERVO_MAX_ANGLE=float(v)))
servo_max_slider.set(SERVO_MAX_ANGLE); servo_max_slider.pack(padx=5,pady=2)

servo_center_slider = tk.Scale(config_frame, from_=0, to=180, resolution=1, orient=tk.HORIZONTAL,
                               label="Servo Center", length=250,
                               command=lambda v: globals().update(SERVO_CENTER=float(v)))
servo_center_slider.set(SERVO_CENTER); servo_center_slider.pack(padx=5,pady=2)

# Turn duration
turn_time_slider = tk.Scale(config_frame, from_=0.1, to=2.0, resolution=0.05, orient=tk.HORIZONTAL,
                            label="Base Turn Time (s)", length=250,
                            command=lambda v: globals().update(BASE_TURN_TIME=float(v)))
turn_time_slider.set(BASE_TURN_TIME); turn_time_slider.pack(padx=5,pady=2)

# ==============================
# THREAD START
# ==============================
def start_thread():
    global robot_running
    if not robot_running:
        robot_running=True
        threading.Thread(target=robot_loop,daemon=True).start()

# ==============================
# MAIN GUI LOOP
# ==============================
update_gui()
root.mainloop()
