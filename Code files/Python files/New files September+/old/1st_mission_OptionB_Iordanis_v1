# ==============================
# üöó Autonomous Wall-Following Robot
# With PID centering, adaptive speed, sharp 90¬∞ turns, lap counter,
# max laps, and emergency stop on obstacle <5cm
# ==============================

# --- Import required libraries ---
import time                                   # Provides timing functions (sleep, delays)
import RPi.GPIO as GPIO                       # Controls Raspberry Pi GPIO pins
from board import SCL, SDA                    # Import I2C pins (SCL/SDA)
import busio                                  # For I2C communication
from adafruit_pca9685 import PCA9685          # Controls PCA9685 PWM driver for motors/servo

# ==============================
# üîß CONFIGURATION VARIABLES
# ==============================

# General timing
START_DELAY = 2                               # Delay before robot starts (seconds)
LOOP_DELAY = 0.1                              # Delay between each control loop iteration (seconds)

# PID control
TARGET_DISTANCE = 50.0                        # Desired distance from wall (cm)
KP = 1.0                                      # Proportional gain for PID
KI = 0.0                                      # Integral gain for PID
KD = 0.8                                      # Derivative gain for PID

# Servo settings
SERVO_CHANNEL = 0                             # PCA9685 channel for steering servo
SERVO_MIN_ANGLE = 50                          # Minimum safe servo angle (hard left)
SERVO_MAX_ANGLE = 130                         # Maximum safe servo angle (hard right)
SERVO_CENTER = 90                             # Servo angle for straight ahead

# Motor settings
MOTOR_FWD = 1                                 # PCA9685 channel for forward motor
MOTOR_REV = 2                                 # PCA9685 channel for reverse motor
SPEED_CRUISE = 20                             # Normal forward speed
SPEED_SLOW = 15                               # Slow speed near walls
TURN_SPEED = 10                               # Speed used while turning

# Turn logic
TURN_TRIGGER_DISTANCE = 90                    # cm: trigger a turn if front wall is closer than this
TURN_OPEN_THRESHOLD = 100                     # cm: side considered "open" if > this distance
BASE_TURN_TIME = 0.8                          # seconds: calibrated 90¬∞ turn duration at BASE_SPEED
BASE_SPEED = 10                               # reference speed used to calibrate turn time

# Lap counting
MAX_LAPS = 3                                  # Stop robot after completing this many laps

# Safety stop
EMERGENCY_STOP_DISTANCE = 5                   # cm: stop robot if obstacle too close

# Ultrasonic sensor pins
TRIG_FRONT, ECHO_FRONT = 22, 23               # Front ultrasonic sensor pins
TRIG_LEFT, ECHO_LEFT = 27, 17                 # Left ultrasonic sensor pins
TRIG_RIGHT, ECHO_RIGHT = 5, 6                 # Right ultrasonic sensor pins

# ==============================
# üîß INITIALIZATION
# ==============================

turns_completed = 0                           # Number of turns completed in current lap
laps_completed = 0                            # Number of laps completed
direction = "left"                            # Default wall-following direction
integral = 0                                  # Integral accumulator for PID
last_error = 0                                # Last error value for PID

time.sleep(START_DELAY)                       # Initial startup delay

i2c = busio.I2C(SCL, SDA)                     # Create I2C bus interface
pca = PCA9685(i2c)                            # Initialize PCA9685 board
pca.frequency = 50                            # Set PWM frequency for servo/motor (50Hz standard for servos)

GPIO.setmode(GPIO.BCM)                        # Use BCM pin numbering mode
for trig in [TRIG_FRONT, TRIG_LEFT, TRIG_RIGHT]:
    GPIO.setup(trig, GPIO.OUT)                # Set ultrasonic trigger pins as outputs
    GPIO.output(trig, GPIO.LOW)               # Initialize trigger pins to LOW
for echo in [ECHO_FRONT, ECHO_LEFT, ECHO_RIGHT]:
    GPIO.setup(echo, GPIO.IN)                 # Set ultrasonic echo pins as inputs

# ==============================
# üîß HELPER FUNCTIONS
# ==============================

def rotate_motor(speed):
    """ Rotate motor forward or backward based on speed (-100 to +100). """
    duty_cycle = int(min(max(abs(speed), 0), 100) / 100 * 65535)  # Convert % speed to PCA9685 duty cycle
    if speed >= 0:                                                # Forward motion
        pca.channels[MOTOR_FWD].duty_cycle = duty_cycle           # Apply PWM to forward channel
        pca.channels[MOTOR_REV].duty_cycle = 0                    # Stop reverse channel
    else:                                                         # Reverse motion
        pca.channels[MOTOR_FWD].duty_cycle = 0                    # Stop forward channel
        pca.channels[MOTOR_REV].duty_cycle = duty_cycle           # Apply PWM to reverse channel

def stop_motor():
    """ Stop both forward and reverse motors. """
    pca.channels[MOTOR_FWD].duty_cycle = 0                        # Stop forward channel
    pca.channels[MOTOR_REV].duty_cycle = 0                        # Stop reverse channel

def set_servo_angle(angle):
    """ Set steering servo to a specific angle (degrees). """
    angle = max(SERVO_MIN_ANGLE, min(SERVO_MAX_ANGLE, angle))     # Clamp angle to safe range
    pulse_min, pulse_max = 1000, 2000                             # ¬µs pulse range for servo
    pulse = int(pulse_min + (pulse_max - pulse_min) * ((angle - SERVO_MIN_ANGLE) / (SERVO_MAX_ANGLE - SERVO_MIN_ANGLE)))
    pca.channels[SERVO_CHANNEL].duty_cycle = int(pulse * 65535 / 20000)  # Convert ¬µs to duty cycle

def get_distance(trigger_pin, echo_pin):
    """ Measure distance using ultrasonic sensor (cm). """
    GPIO.output(trigger_pin, GPIO.HIGH)                           # Send trigger pulse HIGH
    time.sleep(0.00001)                                           # Keep HIGH for 10¬µs
    GPIO.output(trigger_pin, GPIO.LOW)                            # Set trigger LOW

    pulse_start, pulse_end = None, None                           # Initialize pulse times
    timeout = time.time() + 0.02                                  # Timeout for pulse detection

    while GPIO.input(echo_pin) == GPIO.LOW:                       # Wait for pulse to start
        pulse_start = time.time()
        if pulse_start > timeout:                                 # If timeout, return None
            return None

    while GPIO.input(echo_pin) == GPIO.HIGH:                      # Wait for pulse to end
        pulse_end = time.time()
        if pulse_end > timeout:                                   # If timeout, return None
            return None

    if pulse_start and pulse_end:                                 # If both times recorded
        pulse_duration = pulse_end - pulse_start                  # Calculate pulse width
        return (pulse_duration * 34300) / 2                       # Convert to distance (cm)
    return None                                                   # Return None if failed

# ==============================
# üîß MAIN LOOP
# ==============================

try:
    while True:
        # --- Check maximum laps condition ---
        if laps_completed >= MAX_LAPS:                            # If max laps reached
            print(f"üèÜ Finished {MAX_LAPS} laps. Stopping robot.") # Print completion message
            stop_motor()                                          # Stop motors
            break                                                 # Exit main loop

        # --- Read ultrasonic sensors ---
        distance_front = get_distance(TRIG_FRONT, ECHO_FRONT)     # Front sensor distance
        distance_left = get_distance(TRIG_LEFT, ECHO_LEFT)        # Left sensor distance
        distance_right = get_distance(TRIG_RIGHT, ECHO_RIGHT)     # Right sensor distance

        # --- Emergency stop check ---
        if distance_front and distance_front < EMERGENCY_STOP_DISTANCE:  # If obstacle <5cm
            print(f"üö® EMERGENCY STOP: Front={distance_front:.1f}cm")    # Print warning
            stop_motor()                                                # Stop motors immediately
            break                                                       # Exit program to stay stopped

        # --- Check if a turn is needed ---
        if distance_front and distance_front < TURN_TRIGGER_DISTANCE:  # If front too close
            print(f"‚ö° Turn needed: Front={distance_front:.1f}cm | L={distance_left}cm | R={distance_right}cm")

            # Decide turn direction
            if distance_left and distance_left > TURN_OPEN_THRESHOLD:  # If left is open
                direction = "left"
            elif distance_right and distance_right > TURN_OPEN_THRESHOLD:  # If right is open
                direction = "right"
            else:                                                       # Otherwise pick larger side
                if (distance_left or 0) > (distance_right or 0):
                    direction = "left"
                else:
                    direction = "right"

            print(f"‚û°Ô∏è Turning {direction.upper()}")

            # Dynamic turn time scaling based on speed
            turn_duration = BASE_TURN_TIME * (BASE_SPEED / TURN_SPEED)

            # Execute sharp turn
            if direction == "left":
                set_servo_angle(SERVO_MIN_ANGLE)   # Hard left steering
            else:
                set_servo_angle(SERVO_MAX_ANGLE)   # Hard right steering

            rotate_motor(TURN_SPEED)              # Move slowly during turn
            time.sleep(turn_duration)             # Wait for ~90¬∞ turn
            stop_motor()                          # Stop motors briefly
            set_servo_angle(SERVO_CENTER)         # Reset steering straight
            time.sleep(0.2)                       # Small pause

            # --- Update turn and lap counters ---
            turns_completed += 1                  # Increment turns
            if turns_completed >= 4:              # If 4 turns, lap completed
                turns_completed = 0               # Reset turn count
                laps_completed += 1               # Increment lap count
                print(f"üèÅ Lap completed! Total laps: {laps_completed}")
            else:
                print(f"‚úÖ Turn completed. Turns so far: {turns_completed}")

            continue                              # Skip PID this cycle

        # --- Normal driving using PID ---
        if distance_left and distance_right:      # If both walls detected
            error = distance_left - distance_right  # Center between both walls
        else:                                     # If only one wall available
            side_sensor = distance_left if direction == "left" else distance_right
            if side_sensor is None:               # If no valid reading
                print("‚ö†Ô∏è Sensor error, skipping cycle")
                continue
            error = TARGET_DISTANCE - side_sensor # Error relative to target distance

        # PID calculations
        integral += error                         # Update integral
        derivative = error - last_error           # Compute derivative
        output = KP * error + KI * integral + KD * derivative  # PID formula
        last_error = error                        # Save error for next cycle

        # Apply steering correction
        new_angle = SERVO_CENTER + output         # Compute servo correction
        set_servo_angle(new_angle)                # Set servo

        # Adjust speed adaptively
        if distance_front and distance_front < 60:  # If wall ahead is close
            rotate_motor(SPEED_SLOW)              # Slow down
        else:
            rotate_motor(SPEED_CRUISE)            # Normal speed

        print(f"Mode=STRAIGHT | L={distance_left}cm R={distance_right}cm | F={distance_front}cm | Err={error:.2f} | Servo={new_angle:.1f} | Laps={laps_completed}")

        time.sleep(LOOP_DELAY)                    # Loop delay for stability

# --- Safe shutdown ---
except KeyboardInterrupt:
    print("üõë Stopping safely...")
    stop_motor()
    GPIO.cleanup()
