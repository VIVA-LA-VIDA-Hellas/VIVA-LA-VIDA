#----------------------------------------------------------------------------------------------------------------------
# Autonomous drive - VivaLaVida
# v4 - 23/9/2025
# v4.1 - remove camera, add logging - 24/9/2025
# v4.2 - improved turn logic and timeout slider - 24/9/2025 
# v4.3 - graph and turn improvements - 25/9/2025
# v4.5 - rewrite
# v4.5 - new turn logic with PID clear after turn
# v4.6 - new wall following rules - 26/9/2025
# v4.7 - new GUI, rewrite
# v4.8 - added gyroscope
# v4.9 - added sliders, max lap, save/load slide values, csv export with data
#
# Logic description
# - Continuously read ultrasonic sensor distances: front, left, and right.
# - Emergency stop: If front distance < stop threshold, halt immediately to prevent collisions.
# - Initiate turn:
#     Triggered when front distance < configured turn trigger.
#     Robot chooses the side with the greater distance (left or right) to turn toward.
#     Moves forward while steering to avoid the obstacle.
#     Turn ends when front sensor reads clear AND (timeout reached OR side distance is reached OR gyroscope degrees reached)
# - Wall-following:
#     Compares left and right distances to maintain a centered path between walls.
#     Adjusts servo angle based on distance to correct robot heading.
#     Applies a deadzone to ignore small deviations and prevent oscillations.
#-----------------------------------------------------------------------------------------------------------------------

import threading
import time
import tkinter as tk
from collections import deque
import RPi.GPIO as GPIO
from board import SCL, SDA
import busio
from adafruit_pca9685 import PCA9685
import adafruit_mpu6050
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import csv
from datetime import datetime
import json
import os
from datetime import datetime
import tkinter.filedialog as fd

# Get directory of the running script
BASE_DIR = os.path.dirname(os.path.abspath(__file__))

# ===============================
# CONFIGURATION VARIABLES
# ===============================

# ---------- Speeds ----------
SPEED_CRUISE = 30             # Motor speed for normal straight driving (0-100%)
SPEED_TURN = 20               # Motor speed during turns (0-100%)

# ---------- Driving ----------
SAFE_MARGIN = 20              # Minimum safe distance from walls (cm) for emergency correction
SOFT_MARGIN = 30              # Distance from wall where small steering corrections start (cm)
MAX_CORRECTION = 7            # Maximum servo correction applied for wall-following (degrees)
STOP_THRESHOLD = 20           # Front distance (cm) at which robot stops immediately

# ---------- Turn management ----------
FRONT_TURN_TRIGGER = 90       # Front distance (cm) at which a turn is triggered
TURN_DECISION_THRESHOLD = 100 # Minimum side distance (cm) to allow turn in that direction
TURN_ANGLE_LEFT = 55          # Servo angle for left turn
TURN_ANGLE_RIGHT = 125        # Servo angle for right turn
FRONT_SAFE_DISTANCE = 200     # Front distance considered safe to end a turn (cm)
TARGET_DISTANCE = 30          # Desired distance from side walls (cm)
TURN_TIMEOUT = 3.0            # Maximum time allowed for a turn (seconds)
TURN_LOCKOUT = 2.0            # Minimum interval between consecutive turns (seconds)
POST_TURN_DURATION = 1.0      # Time to drive straight after a turn (seconds)

# ---------- Turn angle constraints ----------
MIN_TURN_ANGLE = 75           # Minimum yaw change (degrees) before turn can stop
MAX_TURN_ANGLE = 105          # Maximum yaw change (degrees) to force stop turn

# ---------- Laps ----------
MAX_LAPS = 3                  # Maximum number of laps before stopping (0 = unlimited)
POST_LAP_DURATION = 1.0       # Time to drive forward after final lap before stopping (seconds)

# ---------- Servo ----------
SERVO_CHANNEL = 0             # PCA9685 channel controlling steering servo
SERVO_CENTER = 90             # Neutral servo angle (degrees)
SERVO_MIN_ANGLE = 50          # Minimum physical servo angle (degrees)
SERVO_MAX_ANGLE = 130         # Maximum physical servo angle (degrees)
SERVO_PULSE_MIN = 1000        # Minimum PWM pulse width (microseconds)
SERVO_PULSE_MAX = 2000        # Maximum PWM pulse width (microseconds)
SERVO_PERIOD = 20000          # Servo PWM period (microseconds)

# ---------- Motor ----------
MOTOR_FWD = 1                 # PCA9685 channel for forward motor control
MOTOR_REV = 2                 # PCA9685 channel for reverse motor control

# ---------- Ultrasonic sensor pins ----------
TRIG_FRONT, ECHO_FRONT = 22, 23  # GPIO pins for front sensor
TRIG_LEFT, ECHO_LEFT = 27, 17    # GPIO pins for left sensor
TRIG_RIGHT, ECHO_RIGHT = 5, 6    # GPIO pins for right sensor

ULTRASONIC_TIMEOUT = 0.02        # Timeout for ultrasonic sensor reading (seconds)
# Max distance measurable by a sensor = timeout×17150 - 0.02x17150=343cm maximum distance
SOUND_SPEED = 17150              # Speed of sound in cm/s for distance calculation

# ---------- Sensor data filtering ----------
N_READINGS = 5                    # Number of readings stored for median filtering

# ---------- Loop timing ----------
LOOP_DELAY = 0.05                 # Delay between main loop iterations (seconds)
TRIG_PULSE_DURATION = 0.00001    # Trigger pulse duration for ultrasonic sensor (seconds)

# ---------- Plotting ----------
MAX_POINTS = 200                   # Maximum number of points to store for plotting

# ===============================
# HARDWARE SETUP
# ===============================
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)
i2c = busio.I2C(SCL, SDA)
pca = PCA9685(i2c)
pca.frequency = 50
mpu = adafruit_mpu6050.MPU6050(i2c)

for trig in [TRIG_FRONT, TRIG_LEFT, TRIG_RIGHT]:
    GPIO.setup(trig, GPIO.OUT)
    GPIO.output(trig, GPIO.LOW)
for echo in [ECHO_FRONT, ECHO_LEFT, ECHO_RIGHT]:
    GPIO.setup(echo, GPIO.IN)

bias = sum(mpu.gyro[2] for _ in range(500)) / 500

# ===============================
# CONTROL FLAGS
# ===============================
loop_flag = False
readings_flag = False
status_text = "Idle"
turn_count = 0
lap_count = 0

# ===============================
# SENSOR DATA STORAGE
# ===============================
time_data = deque(maxlen=MAX_POINTS)
front_data = deque(maxlen=MAX_POINTS)
left_data = deque(maxlen=MAX_POINTS)
right_data = deque(maxlen=MAX_POINTS)
angle_data = deque(maxlen=MAX_POINTS)
state_data = deque(maxlen=MAX_POINTS)

# ===============================
# ROBOT CONTROLLER
# ===============================
class RobotController:
    def __init__(self, pca):
        self.pca = pca
        self.front_history = deque(maxlen=N_READINGS)
        self.left_history = deque(maxlen=N_READINGS)
        self.right_history = deque(maxlen=N_READINGS)

    def set_filter_size(self, n):
        self.front_history = deque(list(self.front_history)[-n:], maxlen=n)
        self.left_history = deque(list(self.left_history)[-n:], maxlen=n)
        self.right_history = deque(list(self.right_history)[-n:], maxlen=n)

    def set_servo(self, angle):
        angle = max(SERVO_MIN_ANGLE, min(SERVO_MAX_ANGLE, angle))
        pulse = int(SERVO_PULSE_MIN + (SERVO_PULSE_MAX - SERVO_PULSE_MIN) *
                    ((angle - SERVO_MIN_ANGLE) / (SERVO_MAX_ANGLE - SERVO_MIN_ANGLE)))
        self.pca.channels[SERVO_CHANNEL].duty_cycle = int(pulse * 65535 / SERVO_PERIOD)

    def rotate_motor(self, speed):
        duty_cycle = int(min(max(abs(speed), 0), 100)/100*65535)
        if speed >= 0:
            self.pca.channels[MOTOR_FWD].duty_cycle = duty_cycle
            self.pca.channels[MOTOR_REV].duty_cycle = 0
        else:
            self.pca.channels[MOTOR_FWD].duty_cycle = 0
            self.pca.channels[MOTOR_REV].duty_cycle = duty_cycle

    def stop_motor(self):
        self.pca.channels[MOTOR_FWD].duty_cycle = 0
        self.pca.channels[MOTOR_REV].duty_cycle = 0

    def get_distance(self, trig, echo):
        try:
            GPIO.output(trig, True)
            time.sleep(TRIG_PULSE_DURATION)
            GPIO.output(trig, False)
            start = time.perf_counter()
            while GPIO.input(echo) == 0:
                if time.perf_counter() - start > ULTRASONIC_TIMEOUT:
                    return None
            pulse_start = time.perf_counter()
            while GPIO.input(echo) == 1:
                if time.perf_counter() - pulse_start > ULTRASONIC_TIMEOUT:
                    return None
            pulse_end = time.perf_counter()
            return (pulse_end - pulse_start) * SOUND_SPEED
        except:
            return None

    def filtered_distance(self, trig, echo, history):
        d = self.get_distance(trig, echo)
        if d is not None:
            history.append(d)
        if history:
            s = sorted(history)
            mid = len(s)//2
            return (s[mid-1]+s[mid])/2 if len(s)%2==0 else s[mid]
        return None

    def safe_straight_control(self, d_left, d_right):
        correction = 0
        if d_left is not None and d_left < SOFT_MARGIN:
            correction = (SOFT_MARGIN - d_left)*2
        elif d_right is not None and d_right < SOFT_MARGIN:
            correction = -(SOFT_MARGIN - d_right)*2
        correction = max(-MAX_CORRECTION, min(MAX_CORRECTION, correction))
        return SERVO_CENTER + correction

    def turn_decision(self, d_left, d_right):
        if d_left is not None and d_left > TURN_DECISION_THRESHOLD:
            return "LEFT"
        if d_right is not None and d_right > TURN_DECISION_THRESHOLD:
            return "RIGHT"
        if d_left is not None and d_right is not None:
            return "LEFT" if d_left > d_right else "RIGHT"
        if d_left is not None:
            return "LEFT"
        if d_right is not None:
            return "RIGHT"
        return "LEFT"

robot = RobotController(pca)

# ===============================
# ROBOT LOOP
# ===============================
def robot_loop():
    global loop_flag, readings_flag, status_text, turn_count, lap_count
    turning = False
    turn_start_time = 0
    last_turn_time = -TURN_LOCKOUT
    post_turn_wait = False
    post_turn_start = 0
    direction = None
    turn_start_yaw = None
    last_yaw = 0.0
    last_time = time.monotonic()
    start_time = time.monotonic()
    d_front = d_left = d_right = yaw = 0.0

    while True:
        current_time = time.monotonic()
        dt = current_time - last_time

        # ----------------------------
        # Only read sensors if readings_flag is True
        # ----------------------------
        if readings_flag:
            d_front = robot.filtered_distance(TRIG_FRONT, ECHO_FRONT, robot.front_history)
            d_left = robot.filtered_distance(TRIG_LEFT, ECHO_LEFT, robot.left_history)
            d_right = robot.filtered_distance(TRIG_RIGHT, ECHO_RIGHT, robot.right_history)
            gyro_z = mpu.gyro[2] - bias
            gyro_z_deg = gyro_z * (180 / 3.14159265)
            last_yaw += gyro_z_deg * dt
            last_time = current_time
            yaw = last_yaw

            elapsed_time = current_time - start_time
            time_data.append(elapsed_time)
            front_data.append(d_front or 0)
            left_data.append(d_left or 0)
            right_data.append(d_right or 0)
            angle_data.append(yaw)
            state_data.append(status_text) 
        else:
            # Reset last_time to avoid large dt jumps when readings start
            last_time = current_time
            # Stop motors just in case
            robot.stop_motor()
            time.sleep(LOOP_DELAY)
            continue

        # ----------------------------
        # Only move robot if loop_flag is True
        # ----------------------------
        if loop_flag:
            # Emergency stop
            if d_front is not None and d_front < STOP_THRESHOLD:
                robot.stop_motor()
                status_text = "Stopped! Obstacle ahead"
                time.sleep(LOOP_DELAY)
                continue

            # Turn initiation
            can_trigger = (d_front is not None and d_front < FRONT_TURN_TRIGGER) and \
                          ((d_left is not None and d_left > TURN_DECISION_THRESHOLD) or \
                           (d_right is not None and d_right > TURN_DECISION_THRESHOLD)) and \
                          (current_time - last_turn_time >= TURN_LOCKOUT)

            if (not turning) and (not post_turn_wait) and can_trigger:
                direction = robot.turn_decision(d_left, d_right)
                turning = True
                turn_start_time = current_time
                turn_start_yaw = yaw
                status_text = f"Turning {direction}"
                turn_count += 1
                if turn_count % 4 == 0:
                    lap_count += 1
                    if MAX_LAPS > 0 and lap_count >= MAX_LAPS:
                        # Drive forward a little before stopping
                        robot.set_servo(SERVO_CENTER)
                        robot.rotate_motor(SPEED_CRUISE)
                        time.sleep(POST_LAP_DURATION)
                        robot.stop_motor()
                        loop_flag = False
                        status_text = f"Stopped - Max Laps ({MAX_LAPS}) reached"
                        continue

            # Turn logic
            if turning:
                angle = TURN_ANGLE_LEFT if direction == "LEFT" else TURN_ANGLE_RIGHT
                side_distance = d_left if direction == "LEFT" else d_right
                robot.set_servo(angle)
                robot.rotate_motor(SPEED_TURN)
                turn_angle = abs(yaw - (turn_start_yaw or 0))
                stop_condition = (d_front and d_front > FRONT_SAFE_DISTANCE and side_distance and side_distance > TARGET_DISTANCE) or \
                                 (current_time - turn_start_time > TURN_TIMEOUT) or \
                                 (turn_angle >= MAX_TURN_ANGLE) or \
                                 (turn_angle >= MIN_TURN_ANGLE and side_distance and side_distance > TARGET_DISTANCE)
                if stop_condition:
                    robot.stop_motor()
                    robot.set_servo(SERVO_CENTER)
                    turning = False
                    last_turn_time = current_time
                    post_turn_wait = True
                    post_turn_start = current_time
                    last_yaw = 0.0
                    turn_start_yaw = None
                    status_text = "Driving (post-turn)"

            # Post-turn
            elif post_turn_wait:
                if current_time - post_turn_start < POST_TURN_DURATION:
                    robot.set_servo(SERVO_CENTER)
                    robot.rotate_motor(SPEED_CRUISE)
                    status_text = "Driving (post-turn)"
                else:
                    post_turn_wait = False

            # Normal cruise
            else:
                servo_angle = robot.safe_straight_control(d_left, d_right)
                robot.set_servo(servo_angle)
                robot.rotate_motor(SPEED_CRUISE)
                status_text = "Driving (cruise)"
        else:
            # If loop not started, stop motors
            robot.stop_motor()
            status_text = "Ready (readings started, loop not started)"

        time.sleep(LOOP_DELAY)

# ===============================
# GUI SECTION
# ===============================
def launch_gui():
    """Initialize Tkinter GUI, matplotlib plots, sliders, and status indicators."""
    global btn_readings, btn_start, btn_stop, root, canvas
    global ax_front, ax_side, ax_angle
    global front_line, left_line, right_line, angle_line
    global status_circle, status_canvas, status_text_id, lbl_status
    global lbl_turns, lbl_laps
    global sliders_frame, slider_vars, btn_export

    root = tk.Tk()
    root.title("VivaLaVida Robot Control")

    slider_vars = {}

    # ---------- Matplotlib Figure ----------
    fig, (ax_front, ax_side, ax_angle) = plt.subplots(3, 1, figsize=(6, 8))
    fig.tight_layout(pad=3.0)

    ax_front.set_ylim(0, 350)
    ax_front.set_title("Front Sensor")
    ax_front.grid(True)
    front_line, = ax_front.plot([], [], color="blue")

    ax_side.set_ylim(-150, 150)
    ax_side.set_title("Left (+Y) vs Right (-Y) Sensors")
    ax_side.grid(True)
    ax_side.axhline(0, color="black")
    left_line, = ax_side.plot([], [], color="green")
    right_line, = ax_side.plot([], [], color="orange")

    ax_angle.set_ylim(-180, 180)
    ax_angle.set_title("Yaw Angle")
    ax_angle.grid(True)
    angle_line, = ax_angle.plot([], [], color="purple")

    # ---------- Buttons ----------
    btn_readings = tk.Button(root, text="Start Readings", command=start_readings,
                             width=20, height=2, bg="blue", fg="white")
    btn_start = tk.Button(root, text="Start Loop", command=start_loop,
                          width=20, height=2, bg="green", fg="white", state="disabled")
    btn_stop = tk.Button(root, text="Stop Loop", command=stop_loop,
                         width=20, height=2, bg="red", fg="white", state="disabled")

    # ---------- Status Labels ----------
    lbl_status = tk.Label(root, text="Idle", font=("Arial", 14))
    lbl_turns = tk.Label(root, text=f"Turns: {turn_count}", font=("Arial", 14))
    lbl_laps = tk.Label(root, text=f"Laps: {lap_count}", font=("Arial", 14))

    # ---------- Circular Status Indicator ----------
    status_canvas = tk.Canvas(root, width=100, height=100, highlightthickness=0, bg=root.cget("bg"))
    status_circle = status_canvas.create_oval(10, 10, 90, 90, fill="grey", outline="")
    status_text_id = status_canvas.create_text(50, 50, text="IDLE", fill="white", font=("Arial", 14, "bold"))

    # ---------- Sliders Frame ----------
    sliders_frame = tk.LabelFrame(root, text="Parameters", padx=10, pady=10)
    sliders_frame.grid(row=0, column=1, rowspan=8, sticky="ns", padx=10, pady=5)

    # ---------- Column 3 frame for actions ----------
    actions_frame = tk.LabelFrame(root, text="Actions", padx=10, pady=10)
    actions_frame.grid(row=0, column=2, rowspan=8, sticky="ns", padx=10, pady=5)

    # ---------- Two-column layout ----------
    btn_readings.grid(row=0, column=0, sticky="ew", padx=5, pady=2)
    btn_start.grid(row=1, column=0, sticky="ew", padx=5, pady=2)
    btn_stop.grid(row=2, column=0, sticky="ew", padx=5, pady=2)
    lbl_status.grid(row=3, column=0, pady=5)
    lbl_turns.grid(row=4, column=0, pady=2)
    lbl_laps.grid(row=5, column=0, pady=2)
    status_canvas.grid(row=6, column=0, pady=5)

    canvas = FigureCanvasTkAgg(fig, master=root)
    canvas.get_tk_widget().grid(row=7, column=0, sticky="nsew", padx=5, pady=5)

    root.grid_columnconfigure(0, weight=1)  # main buttons + plots
    root.grid_columnconfigure(1, weight=0)  # sliders
    root.grid_columnconfigure(2, weight=0)  # actions
    root.grid_rowconfigure(7, weight=1)     # plot row

    # ---------- Slider Definitions ----------
    slider_groups = {
        "Speeds": [
            ("Cruise Speed (%)", "SPEED_CRUISE", 0, 100, "int"),
            ("Turn Speed (%)", "SPEED_TURN", 0, 100, "int")
        ],
        "Driving & Safety, Wall following": [
            ("Safe side Margin (cm)", "SAFE_MARGIN", 0, 100, "int"),
            ("Soft side Margin (cm)", "SOFT_MARGIN", 0, 100, "int"),
            ("Max Angle Correction dif at Soft Margin (o)", "MAX_CORRECTION", 0, 45, "int"),
            ("Stop Threshold (cm)", "STOP_THRESHOLD", 0, 100, "int")
        ],
        "Turns - how to initiate": [
            ("Front Turn Trigger (cm)", "FRONT_TURN_TRIGGER", 50, 150, "int"),
            ("Turn Decision Threshold (Left/Right) (cm)", "TURN_DECISION_THRESHOLD", 0, 200, "int")
        ],
        "Turns - how to end": [
            ("Turn Timeout (s)", "TURN_TIMEOUT", 1, 10, "float"),
            ("Target Distance from turn side (cm)", "TARGET_DISTANCE", 10, 100, "int"),
            ("Min Turn Angle (o)", "MIN_TURN_ANGLE", 60, 90, "int"),
            ("Max Turn Angle (o)", "MAX_TURN_ANGLE", 90, 120, "int"),
            ("Post Turn Duration (s)", "POST_TURN_DURATION", 0.1, 5, "float"),
            ("Turn Lockout (s)", "TURN_LOCKOUT", 1, 10, "float")
        ],
        "Other": [
            ("Sensor Filter N (Median)", "N_READINGS", 1, 20, "int"),
            ("Max Laps - 0 for infinite", "MAX_LAPS", 0, 20, "int")
        ]
    }

    # ---------- Create Sliders ----------
    for group_name, sliders in slider_groups.items():
        group_frame = tk.LabelFrame(sliders_frame, text=group_name, padx=5, pady=5)
        group_frame.pack(fill="x", pady=5)
        for label_text, var_name, vmin, vmax, vartype in sliders:
            frame = tk.Frame(group_frame)
            frame.pack(fill="x", pady=2)

            if vartype == "float":
                var = tk.DoubleVar(value=globals()[var_name])
                res = 0.1
            else:
                var = tk.IntVar(value=globals()[var_name])
                res = 1

            slider_vars[var_name] = var

            scale = tk.Scale(frame, from_=vmin, to=vmax, orient="horizontal",
                             variable=var, resolution=res)
            scale.pack(side="left", fill="x", expand=True)

            lbl_val = tk.Label(frame, text=f"{label_text}: {var.get()}", width=25, anchor="w")
            lbl_val.pack(side="right", padx=5)

            def make_callback(lbl, name, var):
                def callback(value):
                    globals()[name] = var.get()
                    if name == "MAX_LAPS" and var.get() == 0:
                        lbl.config(text=f"{label_text}: ∞")
                    else:
                        lbl.config(text=f"{label_text}: {var.get():.1f}" if isinstance(var.get(), float) else f"{label_text}: {var.get()}")
                return callback

            scale.config(command=make_callback(lbl_val, var_name, var))

    # ---------- Buttons under sliders ----------
    btn_export = tk.Button(actions_frame, text="Export CSV", command=export_data_csv,
                       width=20, height=2, bg="purple", fg="white")
    btn_export.pack(pady=10, fill="x")

    btn_save_sliders = tk.Button(actions_frame, text="Save Sliders", command=save_sliders_json,
                             width=20, height=2, bg="green", fg="white")
    btn_save_sliders.pack(pady=5, fill="x")

    btn_load_sliders = tk.Button(actions_frame, text="Load Sliders", command=load_sliders_json,
                             width=20, height=2, bg="blue", fg="white")
    btn_load_sliders.pack(pady=5, fill="x")

    # ===============================
    # GUI Update Functions (nested)
    # ===============================
    def status_color(state: str) -> str:
        if "Stopped" in state:
            return "red"
        elif "Turning" in state:
            return "yellow"
        elif "Driving" in state:
            return "green"
        elif "Loop Started" in state or "Sensor readings started" in state:
            return "blue"
        else:
            return "grey"

    def status_label(state: str) -> str:
        if "Stopped" in state:
            return "STOP"
        elif "Turning" in state:
            return "TURN"
        elif "Driving" in state:
            return "GO"
        elif "Loop Started" in state:
            return "LOOP"
        elif "Sensor readings started" in state:
            return "READ"
        else:
            return "IDLE"

    def update_status():
        lbl_status.config(text=status_text)
        status_canvas.itemconfig(status_circle, fill=status_color(status_text))
        status_canvas.itemconfig(status_text_id, text=status_label(status_text))
        lbl_turns.config(text=f"Turns: {turn_count}")
        lbl_laps.config(text=f"Laps: {lap_count}" if slider_vars["MAX_LAPS"].get() > 0 else f"Laps: {lap_count}/∞")
        root.after(200, update_status)

    def update_plot():
        if time_data:
            front_line.set_data(range(len(front_data)), front_data)
            left_line.set_data(range(len(left_data)), left_data)
            right_line.set_data(range(len(right_data)), [-v for v in right_data])
            angle_line.set_data(range(len(angle_data)), angle_data)

            ax_front.set_xlim(0, MAX_POINTS)
            ax_side.set_xlim(0, MAX_POINTS)
            ax_angle.set_xlim(0, MAX_POINTS)

            if angle_data:
                min_angle = min(angle_data)
                max_angle = max(angle_data)
                if max_angle - min_angle > 180:
                    ax_angle.set_ylim(-180, 180)
                else:
                    ax_angle.set_ylim(min_angle - 10, max_angle + 10)

            canvas.draw()

        root.after(100, update_plot)

    def on_closing():
        stop_loop()
        GPIO.cleanup()
        root.destroy()

    root.protocol("WM_DELETE_WINDOW", on_closing)
    update_status()
    update_plot()
    root.mainloop()

# ===============================
# GUI UPDATE FUNCTIONS
# ===============================
def status_color(state: str) -> str:
    if "Stopped" in state:
        return "red"
    elif "Turning" in state:
        return "yellow"
    elif "Driving" in state:
        return "green"
    elif "Loop Started" in state or "Sensor readings started" in state:
        return "blue"
    else:
        return "grey"

def status_label(state: str) -> str:
    if "Stopped" in state:
        return "STOP"
    elif "Turning" in state:
        return "TURN"
    elif "Driving" in state:
        return "GO"
    elif "Loop Started" in state:
        return "LOOP"
    elif "Sensor readings started" in state:
        return "READ"
    else:
        return "IDLE"

def update_status():
    lbl_status.config(text=status_text)
    status_canvas.itemconfig(status_circle, fill=status_color(status_text))
    status_canvas.itemconfig(status_text_id, text=status_label(status_text))
    lbl_turns.config(text=f"Turns: {turn_count}")
    lbl_laps.config(text=f"Laps: {lap_count}" if slider_vars["MAX_LAPS"].get() > 0 else f"Laps: {lap_count}/∞")
    root.after(200, update_status)

def update_plot():
    if time_data:
        front_line.set_data(range(len(front_data)), front_data)
        left_line.set_data(range(len(left_data)), left_data)
        right_line.set_data(range(len(right_data)), [-v for v in right_data])
        angle_line.set_data(range(len(angle_data)), angle_data)

        ax_front.set_xlim(0, MAX_POINTS)
        ax_side.set_xlim(0, MAX_POINTS)
        ax_angle.set_xlim(0, MAX_POINTS)

        if angle_data:
            min_angle = min(angle_data)
            max_angle = max(angle_data)
            if max_angle - min_angle > 180:
                ax_angle.set_ylim(-180, 180)
            else:
                ax_angle.set_ylim(min_angle - 10, max_angle + 10)

        canvas.draw()

    root.after(100, update_plot)

def on_closing():
    stop_loop()
    GPIO.cleanup()
    root.destroy()

# -------------------------
# Start / Stop
# -------------------------
def start_readings():
    """Enable sensor readings and allow loop start."""
    global readings_flag, status_text
    readings_flag = True
    status_text = "Sensor readings started"
    btn_readings.config(state="disabled")
    btn_start.config(state="normal")

    # Automatically start robot_loop thread once
    if not hasattr(start_readings, "thread_started"):
        threading.Thread(target=robot_loop, daemon=True).start()
        start_readings.thread_started = True

def start_loop():
    """Start the robot driving loop."""
    global loop_flag, status_text
    if not readings_flag:
        print("Start sensor readings first!")
        return

    loop_flag = True
    status_text = "Loop Started"
    btn_start.config(state="disabled")
    btn_stop.config(state="normal")

def stop_loop():
    """Stop the robot loop and motor."""
    global loop_flag, status_text
    loop_flag = False
    robot.stop_motor()
    status_text = "Stopped"
    btn_start.config(state="normal")
    btn_stop.config(state="disabled")

# -------------------------
# Export to CSV
# -------------------------
def export_data_csv():
    from datetime import datetime
    filename = f"viva_data_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
    slider_values = {name: var.get() for name, var in slider_vars.items()}

    with open(filename, mode='w', newline='') as file:
        writer = csv.writer(file)
        header = ["Time (s)", "Front (cm)", "Left (cm)", "Right (cm)", "Yaw (deg)", "State"]
        header += [name for name in slider_values.keys()]
        writer.writerow(header)

        for i in range(len(time_data)):
            row = [
                round(time_data[i], 2),
                round(front_data[i], 2),
                round(left_data[i], 2),
                round(right_data[i], 2),
                round(angle_data[i], 2),
                state_data[i]
            ]
            row += [slider_values[name] for name in slider_values.keys()]
            writer.writerow(row)

    print(f"Data exported to {filename}")

# -------------------------
# Save/Load Slider Config
# -------------------------
def save_sliders_json():
    default_filename = f"sliders_config_{datetime.now().strftime('%Y%m%d')}.json"
    file_path = fd.asksaveasfilename(initialdir=BASE_DIR,
                                     initialfile=default_filename,
                                     defaultextension=".json",
                                     filetypes=[("JSON files", "*.json")],
                                     title="Save Slider Configuration")
    if file_path:
        data = {name: var.get() for name, var in slider_vars.items()}
        with open(file_path, "w") as f:
            json.dump(data, f, indent=4)
        print(f"Slider values saved to {file_path}"))

def load_sliders_json():
    file_path = fd.askopenfilename(initialdir=BASE_DIR,
                                   defaultextension=".json",
                                   filetypes=[("JSON files", "*.json")],
                                   title="Load Slider Configuration")
    if file_path:
        try:
            with open(file_path, "r") as f:
                data = json.load(f)
            for name, value in data.items():
                if name in slider_vars:
                    slider_vars[name].set(value)
                    globals()[name] = value
            print(f"Sliders restored from {file_path}")
        except Exception as e:
            print(f"Failed to load sliders: {e}")

# ===============================
# MAIN
# ===============================
if __name__ == "__main__":
    #threading.Thread(target=robot_loop, daemon=True).start()
    launch_gui()
