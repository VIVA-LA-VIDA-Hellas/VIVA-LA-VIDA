#----------------------------------------------------------------------------------------------------------------------
# Autonomous drive - VivaLaVida
# v5.0 - Gold version
# v5.1 - minor fixes
# v5.2 - threaded, low-latency sensor reading, Exponential Moving Average (EMA) layer, turn initiation logic
# v5.3:
#     - fix stop loop to stop the motor (change at RobotState.IDLE), 
#     - added timing and continuous reading in tof initialization and also changed tof settings on closing, 
#     - added linear accelaration in RobotState.IDLE during start, 
#     - def sensor_reader reduced sleep (0.005 from 0.01)
# v5.4:
#     - gpiozero, 
#     - added SENSOR_DELAY variable, 
#     - speed factor per state
#     - last_turn_time set to a high value to enable initial turn
#     - Removed logic to end turn based on front/side distance
# v5.5:
#     - add numners to plots
#     - changes def turn_decision
# v5.6:
#     - turn end logic change (corrected yaw calculation)
#     - change to keep wall following logic
# TO DO - check time.sleep(LOOP_DELAY) if needed in all instances
# TO DO - test end turn only with gyro and not distances
# to do: add buttons & leds & buzzer
# to do: reduce speed if sensors are none or before turning, logic for movements after stop due to obstacle
#---------------------------------------------------------------------------------------------------------------------

#errors:
# readings button does not work

# ===============================
# IMPORTS
# ===============================

import threading
import time
import tkinter as tk
from collections import deque
import RPi.GPIO as GPIO
from board import SCL, SDA
import busio
from adafruit_pca9685 import PCA9685
import adafruit_mpu6050
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import csv
from datetime import datetime
import json
import os
import tkinter.filedialog as fd
import board
import digitalio
import adafruit_vl53l0x
from enum import Enum, auto
from gpiozero import DistanceSensor
from gpiozero import Device
from gpiozero.pins.pigpio import PiGPIOFactory

#Device.pin_factory = PiGPIOFactory() - pigpio, needs the daemon.

BASE_DIR = os.path.dirname(os.path.abspath(__file__)) # Get directory of the running script

# ===============================
# CONFIGURATION VARIABLES
# ===============================

# ---------- Initialization ----------
USE_GUI = 1                   # 1 = run with GUI (Tkinter), 0 = run headless (no GUI)
USE_TOF_SIDES = 1             # Side:  0 = Ultrasonic, 1 = ToF
USE_TOF_FRONT = 0             # Front: 0 = Ultrasonic, 1 = ToF

# ---------- Speeds ----------
#SPEED_CRUISE = 20             # Motor speed for normal straight driving (0-100%)
#SPEED_TURN = 18               # Motor speed during turns (0-100%)

SPEED_IDLE = 0
SPEED_STOPPED = 0
SPEED_CRUISE = 20
SPEED_TURN_INIT = 13
SPEED_TURN = 15
SPEED_POST_TURN = 18

STATE_SPEED = {
    "IDLE": SPEED_IDLE,
    "STOPPED": SPEED_STOPPED,
    "CRUISE": SPEED_CRUISE,
    "TURN_INIT": SPEED_TURN_INIT,
    "TURNING": SPEED_TURN,
    "POST_TURN": SPEED_POST_TURN
}

# ---------- Driving ----------
SOFT_MARGIN = 30              # Distance from wall where small steering corrections start (cm)
MAX_CORRECTION = 9            # Maximum servo correction applied for wall-following (degrees)
STOP_THRESHOLD = 20           # Front distance (cm) at which robot stops immediately
CORRECTION_DURATION = 0.25     # How long a side-correction is held (seconds)

FOLLOW_SIDE = "RIGHT"   # or "LEFT"
KP_WALL = 1.4           # try 1.0‚Äì2.0

# ---------- Turn management ----------
FRONT_TURN_TRIGGER = 90       # Front distance (cm) at which a turn is triggered
TURN_DECISION_THRESHOLD = 85  # Minimum side distance (cm) to allow turn in that direction
TURN_ANGLE_LEFT = 60          # Servo angle for left turn
TURN_ANGLE_RIGHT = 120        # Servo angle for right turn
FRONT_SAFE_DISTANCE = 160     # Front distance considered safe to end a turn (cm)
SIDE_SAFE_DISTANCE = 30       # Side distance considered safe to end a turn (cm)
TARGET_DISTANCE = 30          # Desired distance from side walls (cm)
TURN_TIMEOUT = 2.0            # Maximum time allowed for a turn (seconds)
TURN_LOCKOUT = 1.5           # Minimum interval between consecutive turns (seconds)
POST_TURN_DURATION = 0.5     # Time to drive straight after a turn (seconds)
LOCK_TURN_DIRECTION = 1       # 1 = enable turn lock direction after 1st turn, 0 = disable
TARGET_TURN_ANGLE = 80        # Degrees to turn per corner
TURN_ANGLE_TOLERANCE = 5      # Acceptable overshoot (degrees)

HEADING_STEP = 90.0           # degrees between cardinals; keep 90 for square track

# ---------- Turn angle constraints ----------
MIN_TURN_ANGLE = 75           # Minimum yaw change (degrees) before turn can stop
MAX_TURN_ANGLE = 105          # Maximum yaw change (degrees) to force stop turn

# ---------- Laps ----------
MAX_LAPS = 3                  # Maximum number of laps before stopping (0 = unlimited)
POST_LAP_DURATION = 0.6       # Time to drive forward after final lap before stopping (seconds)

# ---------- Servo ----------
SERVO_CHANNEL = 0             # PCA9685 channel controlling steering servo
SERVO_CENTER = 88             # Neutral servo angle (degrees)
SERVO_MIN_ANGLE = 50          # Minimum physical servo angle (degrees)
SERVO_MAX_ANGLE = 130         # Maximum physical servo angle (degrees)
SERVO_PULSE_MIN = 1000        # Minimum PWM pulse width (microseconds)
SERVO_PULSE_MAX = 2000        # Maximum PWM pulse width (microseconds)
SERVO_PERIOD = 20000          # Servo PWM period (microseconds)

# ---------- Motor ----------
MOTOR_FWD = 1                 # PCA9685 channel for forward motor control
MOTOR_REV = 2                 # PCA9685 channel for reverse motor control

# ---------- Ultrasonic sensor pins ----------
TRIG_FRONT, ECHO_FRONT = 22, 23  # GPIO pins for front sensor
TRIG_LEFT, ECHO_LEFT = 27, 17    # GPIO pins for left sensor
TRIG_RIGHT, ECHO_RIGHT = 5, 6    # GPIO pins for right sensor

ULTRASONIC_TIMEOUT = 0.02        # Timeout for ultrasonic sensor reading (seconds)
# Max¬†distance measurable by a sensor = timeout√ó17150 - 0.02x17150=343cm maximum distance
SOUND_SPEED = 17150              # Speed of sound in cm/s for distance calculation for a round trip

# ---------- Sensor data filtering ----------
N_READINGS = 5                    # Number of readings stored for median filtering
US_QUEUE_LEN = 5            #Queue_len for Ultrasonic gpiozero.DistanceSensor
FILTER_ALPHA = 1.0              # 0.1 = smoother, 0.5 = faster reaction, 1 to ignore filter
FILTER_JUMP = 999            # maximum jump (cm) allowed between readings
FILTER_ALPHA_TOF = 1.0
FILTER_JUMP_TOF = 999

# ---------- Loop timing ----------
LOOP_DELAY = 0.02                # Delay between main loop iterations (seconds)
SENSOR_DELAY = 0.02
TRIG_PULSE_DURATION = 0.000010     # Trigger pulse duration for ultrasonic sensor (seconds)

# ---------- Plotting ----------
MAX_POINTS = 500                   # Maximum number of points to store for plotting

def wrap_deg(d):
    # [-180, 180)
    return ((d + 180.0) % 360.0) - 180.0

def snap_to_grid(d, step=90.0):
    # nearest multiple of `step` (e.g., 90¬∞)
    return round(d / step) * step

# ===============================
# HARDWARE SETUP
# ===============================

GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)
i2c = busio.I2C(board.SCL, board.SDA, frequency=400000 )

START_BTN = 21
GPIO.setup(START_BTN, GPIO.IN, pull_up_down=GPIO.PUD_UP)

# ===============================
# SENSOR INITIALIZATION (ToF + Ultrasonic, flexible for mixed scenarios)
# ===============================

vl53_left = vl53_right = vl53_front = vl53_back = None
us_left = us_right = us_front = None

try:
    # --------- ToF sensors ----------
    if USE_TOF_SIDES or USE_TOF_FRONT:
        print("Initializing VL53L0X ToF sensors...")
        # XSHUT pins setup (for powering sensors individually)
        xshut_left  = digitalio.DigitalInOut(board.D16)
        xshut_right = digitalio.DigitalInOut(board.D25)
        xshut_front = digitalio.DigitalInOut(board.D26)
        xshut_back  = digitalio.DigitalInOut(board.D24)
        for xshut in [xshut_left, xshut_right, xshut_front, xshut_back]:
            xshut.direction = digitalio.Direction.OUTPUT
            xshut.value = False  # power down
        time.sleep(0.1)

        # Initialize left ToF if needed
        if USE_TOF_SIDES:
            xshut_left.value = True
            time.sleep(0.05)
            vl53_left = adafruit_vl53l0x.VL53L0X(i2c)
            vl53_left.set_address(0x30)
            vl53_left.measurement_timing_budget = 20000
            vl53_left.start_continuous()
            print("‚úÖ Left ToF sensor set to address 0x30")

        # Initialize right ToF if needed
        if USE_TOF_SIDES:
            xshut_right.value = True
            time.sleep(0.05)
            vl53_right = adafruit_vl53l0x.VL53L0X(i2c)
            vl53_right.set_address(0x31)
            vl53_right.measurement_timing_budget = 20000
            vl53_right.start_continuous()
            print("‚úÖ Right ToF sensor set to address 0x31")

        # Initialize front ToF if needed
        if USE_TOF_FRONT:
            xshut_front.value = True
            time.sleep(0.05)
            vl53_front = adafruit_vl53l0x.VL53L0X(i2c)
            vl53_front.set_address(0x32)
            vl53_front.measurement_timing_budget = 20000
            vl53_front.start_continuous()
            print("‚úÖ Front ToF sensor set to address 0x32")

        # Initialize back ToF (optional, if you want to use it)
        xshut_back.value = True
        time.sleep(0.05)
        vl53_back = adafruit_vl53l0x.VL53L0X(i2c)
        vl53_back.set_address(0x33)
        vl53_back.measurement_timing_budget = 20000
        vl53_back.start_continuous()
        print("‚úÖ Back ToF sensor set to address 0x33")

except Exception as e:
    print(f"[ERROR] VL53L0X initialization failed: {e}")
    # fallback to ultrasonic if ToF fails
    USE_TOF_SIDES = 0
    USE_TOF_FRONT = 0
    vl53_left = vl53_right = vl53_front = vl53_back = None

time.sleep(0.2)

# --------- Ultrasonic sensors ----------
# Initialize ultrasonic sensors only if that sensor is set to ultrasonic
if not USE_TOF_FRONT:
    us_front = DistanceSensor(echo=ECHO_FRONT, trigger=TRIG_FRONT, max_distance=3.43, queue_len=US_QUEUE_LEN)
if not USE_TOF_SIDES:
    us_left  = DistanceSensor(echo=ECHO_LEFT,  trigger=TRIG_LEFT,  max_distance=3.43, queue_len=US_QUEUE_LEN)
    us_right = DistanceSensor(echo=ECHO_RIGHT, trigger=TRIG_RIGHT, max_distance=3.43, queue_len=US_QUEUE_LEN)

print("Sensors initialized:")
print(f"  Front: {'ToF' if USE_TOF_FRONT else 'Ultrasonic'}")
print(f"  Left : {'ToF' if USE_TOF_SIDES else 'Ultrasonic'}")
print(f"  Right: {'ToF' if USE_TOF_SIDES else 'Ultrasonic'}")

    
pca = PCA9685(i2c)
pca.frequency = 50
mpu = adafruit_mpu6050.MPU6050(i2c)

#for trig in [TRIG_FRONT, TRIG_LEFT, TRIG_RIGHT]:
#    GPIO.setup(trig, GPIO.OUT)
#    GPIO.output(trig, GPIO.LOW)
#for echo in [ECHO_FRONT, ECHO_LEFT, ECHO_RIGHT]:
#    GPIO.setup(echo, GPIO.IN)

# ---------- Calibrate gyro bias at startup ----------
print("Calibrating gyro...")
N = 500
bias = 0
for _ in range(N):
    bias += mpu.gyro[2]
    time.sleep(0.005)
bias /= N
#print(f"Gyro bias: {bias}")

# ===============================
# CONTROL FLAGS & STORAGE
# ===============================

# ---------- CONTROL FLAGS ----------

loop_flag = False
readings_flag = False
status_text = "Idle"
turn_count = 0
lap_count = 0

# ---------- SENSOR DATA STORAGE ----------
time_data = deque(maxlen=MAX_POINTS)
front_data = deque(maxlen=MAX_POINTS)
left_data = deque(maxlen=MAX_POINTS)
right_data = deque(maxlen=MAX_POINTS)
angle_data = deque(maxlen=MAX_POINTS)
state_data = deque(maxlen=MAX_POINTS)

# ===============================
# THREADED SENSOR READING
# ===============================
sensor_data = {
    "front": None,
    "left": None,
    "right": None
}
sensor_lock = threading.Lock()

# ===============================
# ROBOT CONTROLLER
# ===============================

class RobotController:
    def __init__(self, pca):
        self.pca = pca
        self.front_history = deque(maxlen=N_READINGS)
        self.left_history = deque(maxlen=N_READINGS)
        self.right_history = deque(maxlen=N_READINGS)
        self.smooth_left = None
        self.smooth_right = None
        self.smooth_front = None
        self.d_front = None
        self.d_left = None
        self.d_right = None
        self.sensor_index = 0
        self.gyro_z_prev = 0

    def set_filter_size(self, n):
        self.front_history = deque(list(self.front_history)[-n:], maxlen=n)
        self.left_history = deque(list(self.left_history)[-n:], maxlen=n)
        self.right_history = deque(list(self.right_history)[-n:], maxlen=n)

    def set_servo(self, angle):
        angle = max(SERVO_MIN_ANGLE, min(SERVO_MAX_ANGLE, angle))
        pulse = int(SERVO_PULSE_MIN + (SERVO_PULSE_MAX - SERVO_PULSE_MIN) *
                    ((angle - SERVO_MIN_ANGLE) / (SERVO_MAX_ANGLE - SERVO_MIN_ANGLE)))
        self.pca.channels[SERVO_CHANNEL].duty_cycle = int(pulse * 65535 / SERVO_PERIOD)

    def rotate_motor(self, speed):
        duty_cycle = int(min(max(abs(speed), 0), 100)/100*65535)
        if speed >= 0:
            self.pca.channels[MOTOR_FWD].duty_cycle = duty_cycle
            self.pca.channels[MOTOR_REV].duty_cycle = 0
        else:
            self.pca.channels[MOTOR_FWD].duty_cycle = 0
            self.pca.channels[MOTOR_REV].duty_cycle = duty_cycle

    def stop_motor(self):
        self.pca.channels[MOTOR_FWD].duty_cycle = 0
        self.pca.channels[MOTOR_REV].duty_cycle = 0

    def set_state_speed(self, state):
        # Set motor speed based on FSM state.
        speed = STATE_SPEED.get(state, SPEED_CRUISE)  # default to cruise if unknown
        self.rotate_motor(speed)

    #def get_distance(self, trig, echo):
    #    try:
    #        GPIO.output(trig, True)
    #        time.sleep(TRIG_PULSE_DURATION)
    #        GPIO.output(trig, False)
    #        start = time.perf_counter()
    #        while GPIO.input(echo) == 0:
    #            if time.perf_counter() - start > ULTRASONIC_TIMEOUT:
    #                return None
    #        pulse_start = time.perf_counter()
    #        while GPIO.input(echo) == 1:
    #            if time.perf_counter() - pulse_start > ULTRASONIC_TIMEOUT:
    #                return None
    #        pulse_end = time.perf_counter()
    #        return (pulse_end - pulse_start) * SOUND_SPEED
    #    except:
    #        return None

    def get_distance(self, sensor):
        #sensor: a gpiozero.DistanceSensor instance
        try:
            d = sensor.distance  # returns meters
            if d is None:
                return None
            return d * 100  # convert to cm
        except:
            return None

    def stable_filter(self, new_val, prev_val, alpha=FILTER_ALPHA, max_jump=FILTER_JUMP):
    #Reject large spikes and apply exponential moving average smoothing.
        if new_val is None:
            return prev_val  # keep previous if invalid
        if prev_val is not None and abs(new_val - prev_val) > max_jump:
            new_val = prev_val  # reject spike
        if prev_val is None:
            return new_val
        return alpha * new_val + (1 - alpha) * prev_val    

    def filtered_distance_us(self, sensor_obj, history, smooth_attr):
        try:
            d = sensor_obj.distance * 100.0  # meters ‚Üí cm
        except:
            d = None
        history.append(d)
    
        valid = [x for x in history if x is not None]
        if not valid:
            return 999
    
        s = sorted(valid)
        mid = len(s) // 2
        median_val = (s[mid - 1] + s[mid]) / 2 if len(s) % 2 == 0 else s[mid]
        avg_val = sum(valid) / len(valid)
        filtered_val = 0.7 * median_val + 0.3 * avg_val
    
        prev_val = getattr(self, smooth_attr)
        smoothed_val = self.stable_filter(filtered_val, prev_val, alpha=FILTER_ALPHA, max_jump=FILTER_JUMP)
        setattr(self, smooth_attr, smoothed_val)
        return smoothed_val

    def get_tof_distance(self, sensor):
        try:
            d = sensor.range  # mm
            if d < 20 or d > 2000:
                return None
            return d / 10.0  # convert mm ‚Üí cm
        except Exception:
            return None

    def filtered_tof(self, sensor, history, smooth_attr):
        d = self.get_tof_distance(sensor)
        history.append(d)
    
        valid = [x for x in history if x is not None]
        if not valid:
            return 999

        s = sorted(valid)
        mid = len(s) // 2
        median_val = (s[mid - 1] + s[mid]) / 2 if len(s) % 2 == 0 else s[mid]
        avg_val = sum(valid) / len(valid)
        filtered_val = 0.7 * median_val + 0.3 * avg_val
    
        prev_val = getattr(self, smooth_attr)
        smoothed_val = self.stable_filter(filtered_val, prev_val, alpha=FILTER_ALPHA_TOF, max_jump=FILTER_JUMP_TOF)
    
        setattr(self, smooth_attr, smoothed_val)
        return smoothed_val

    def safe_straight_control(self, d_left, d_right):
        correction = 0
        if d_left is not None and d_left < SOFT_MARGIN:
            correction = (SOFT_MARGIN - d_left)*2
        elif d_right is not None and d_right < SOFT_MARGIN:
            correction = -(SOFT_MARGIN - d_right)*2
        correction = max(-MAX_CORRECTION, min(MAX_CORRECTION, correction))
        return SERVO_CENTER + correction

    def wall_follow_simple(self, d_left, d_right, side=FOLLOW_SIDE):
        #Keep a fixed distance from the chosen wall using a plain P controller.
        dist = d_left if side == "LEFT" else d_right
        if dist is None or dist == 999:
            return SERVO_CENTER  # no reading ‚Üí go straight
    
        error = TARGET_DISTANCE - dist      # + if too far, - if too close
        correction = KP_WALL * error        # P only
        if side == "RIGHT":
            correction = -correction        # flip sign for right wall
    
        # clamp to your steering limit
        correction = max(-MAX_CORRECTION, min(MAX_CORRECTION, correction))
        return SERVO_CENTER + correction
    
    def turn_decision(self, d_left, d_right):
        left_open  = (d_left  is None) or (d_left  == 999) or (d_left  > TURN_DECISION_THRESHOLD)
        right_open = (d_right is None) or (d_right == 999) or (d_right > TURN_DECISION_THRESHOLD)
    
        # Decide only when exactly one side is open; otherwise keep trying.
        if left_open ^ right_open:               #XOR: exactly one is True
            return "LEFT" if left_open else "RIGHT"
        return None # both open or both closed ‚Üí keep trying

robot = RobotController(pca)

def sensor_reader():
    global sensor_data
    while True:
        # Left sensor
        if vl53_left:  # ToF
            left = robot.filtered_tof(vl53_left, robot.left_history, "smooth_left")
        elif us_left:  # ultrasonic
            left = robot.filtered_distance_us(us_left, robot.left_history, "smooth_left")
        else:
            left = None

        # Right sensor
        if vl53_right:
            right = robot.filtered_tof(vl53_right, robot.right_history, "smooth_right")
        elif us_right:
            right = robot.filtered_distance_us(us_right, robot.right_history, "smooth_right")
        else:
            right = None

        # Front sensor
        if vl53_front:
            front = robot.filtered_tof(vl53_front, robot.front_history, "smooth_front")
        elif us_front:
            front = robot.filtered_distance_us(us_front, robot.front_history, "smooth_front")
        else:
            front = None

        # Save readings in global dictionary
        with sensor_lock:
            sensor_data["front"] = front
            sensor_data["left"] = left
            sensor_data["right"] = right

        time.sleep(SENSOR_DELAY)

# ===============================
# FINITE STATE MACHINE: robot_loop
# ===============================
class RobotState(Enum):
    IDLE = auto()
    CRUISE = auto()
    TURN_INIT = auto()
    TURNING = auto()
    POST_TURN = auto()
    STOPPED = auto()

# Keep a global locked_turn_direction variable to persist across runs (reset in stop_loop)
locked_turn_direction = None

def robot_loop():
    
    global loop_flag, readings_flag, status_text, turn_count, lap_count, locked_turn_direction

    state = RobotState.IDLE
    direction = None
    yaw = 0.0
    turn_start_yaw = 0.0
    turn_start_time = 0.0
    post_turn_start = 0.0
    #last_turn_time = -TURN_LOCKOUT
    last_turn_time = -999
    last_time = time.monotonic()
    start_time = time.monotonic()
    use_post_turn_ref = False
    post_turn_ref_diff = None
    correction_active = False
    correction_start_time = 0.0
    correction_angle = SERVO_CENTER
    current_servo_angle = SERVO_CENTER

    turn_reference_side_distance = None
    
    target_heading = None                   # absolute heading goal for current turn
    HEADING_TOL = float(TURN_ANGLE_TOLERANCE)
    Kp_trim = 0.6                           # small P for post-turn heading trim

    # Ensure robot stopped at start
    robot.stop_motor()
    robot.set_servo(SERVO_CENTER)

    while True:
        current_time = time.monotonic()
        dt = current_time - last_time
        last_time = current_time

        if not readings_flag or not loop_flag:
            # if readings not started, keep motors stopped and idle
            robot.stop_motor()
            state = RobotState.IDLE
            status_text = "Idle"
            time.sleep(LOOP_DELAY)
            continue

        # ----------------------------
        # Sensor reads & gyro integration (always update while readings_flag)
        # ----------------------------
        with sensor_lock:
            d_front = sensor_data["front"]
            d_left = sensor_data["left"]
            d_right = sensor_data["right"]

        # Update robot attributes for plotting/logging and decision making
        robot.d_front = d_front
        robot.d_left = d_left
        robot.d_right = d_right

        # Gyro integration
        raw_gyro_z = mpu.gyro[2] - bias
        ALPHA = 0.8
        gyro_z_filtered = ALPHA * raw_gyro_z + (1 - ALPHA) * getattr(robot, 'gyro_z_prev', 0)
        robot.gyro_z_prev = gyro_z_filtered
        gyro_z_deg = gyro_z_filtered * (180 / 3.14159265)
        yaw += gyro_z_deg * dt

        # Append to deques for plotting/logging
        elapsed_time = current_time - start_time
        time_data.append(elapsed_time)
        front_data.append(robot.d_front if robot.d_front is not None else 0)
        left_data.append(robot.d_left if robot.d_left is not None else 0)
        right_data.append(robot.d_right if robot.d_right is not None else 0)
        #angle_data.append(yaw)
        angle_data.append(wrap_deg(yaw))
        state_data.append(state.name)

        # ----------------------------
        # FSM transitions & actions
        # ----------------------------
        if state == RobotState.IDLE:
            status_text = "Ready (readings started, loop not started)" if readings_flag else "Idle"
            robot.stop_motor()
            robot.set_servo(SERVO_CENTER)
            correction_active = False
            if loop_flag:
                state = RobotState.CRUISE
                status_text = "Driving (cruise)"
                for speed in range(0, SPEED_CRUISE + 1):
                    if not loop_flag:
                        robot.stop_motor()
                        break
                    robot.rotate_motor(speed)
                    time.sleep(0.01)

        elif state == RobotState.CRUISE:
            status_text = "Driving (cruise)"
        
            # -------------------------------
            # Emergency stop: immediate
            # -------------------------------
            if robot.d_front is not None and robot.d_front < STOP_THRESHOLD:
                robot.stop_motor()
                status_text = "Stopped! Obstacle ahead"
                print(status_text)
                state = RobotState.STOPPED
                continue
        
            # -------------------------------
            # Check if we can trigger a turn
            # -------------------------------
            left_far = (robot.d_left is None) or (robot.d_left > TURN_DECISION_THRESHOLD)
            right_far = (robot.d_right is None) or (robot.d_right > TURN_DECISION_THRESHOLD)
            can_trigger = (robot.d_front is not None and robot.d_front < FRONT_TURN_TRIGGER) and \
                          (left_far or right_far) and \
                          (current_time - last_turn_time >= TURN_LOCKOUT)
        
            # -------------------------------
            # Decide to transition to TURN_INIT
            # -------------------------------
            if can_trigger and loop_flag:
                proposed_direction = robot.turn_decision(robot.d_left, robot.d_right)
        
                if proposed_direction is None or proposed_direction == 999:
                    # No side available: keep driving straight until a valid turn appears
                    #desired_servo_angle = robot.safe_straight_control(robot.d_left, robot.d_right)
                    desired_servo_angle = robot.wall_follow_simple(robot.d_left, robot.d_right, FOLLOW_SIDE)
                    robot.set_servo(desired_servo_angle)
                    robot.rotate_motor(SPEED_TURN_INIT)
                    #robot.set_state_speed(state.name)
                    status_text = "Approaching turn - waiting for side clear"
                    print(status_text)
                    time.sleep(LOOP_DELAY)
                    continue
        
                # -------------------------------
                # Implement turn lock mechanic
                # -------------------------------
                if LOCK_TURN_DIRECTION == 1:
                    if locked_turn_direction is None:
                        locked_turn_direction = proposed_direction
                        print(f"Turn direction locked to {locked_turn_direction}")
                    elif proposed_direction != locked_turn_direction:
                        # Ignore side until it matches locked direction
                        status_text = f"Ignoring {proposed_direction} (locked to {locked_turn_direction})"
                        print(status_text)
                        robot.set_servo(robot.safe_straight_control(robot.d_left, robot.d_right))
                        #robot.rotate_motor(SPEED_CRUISE)
                        robot.set_state_speed(state.name)
                        time.sleep(LOOP_DELAY)
                        continue
                    direction = locked_turn_direction
                else:
                    direction = proposed_direction
        
                # -------------------------------
                # Transition to TURN_INIT
                # -------------------------------
                print(f"Triggering turn: {direction}")
                state = RobotState.TURN_INIT
                continue
        
            # -------------------------------
            # Normal cruise servo control
            # Safe straight control active only after the 1st turn
            # -------------------------------
            if turn_count >= 1:
                #desired_servo_angle = robot.safe_straight_control(robot.d_left, robot.d_right)
                follow_side = FOLLOW_SIDE
                desired_servo_angle = robot.wall_follow_simple(robot.d_left, robot.d_right, follow_side)
                robot.set_servo(desired_servo_angle)
            else:
                desired_servo_angle = SERVO_CENTER
                correction_active = False
                
            robot.set_state_speed(state.name)
            
            # -------------------------------
            # Timed servo correction behavior
            # -------------------------------
            if correction_active:
                if current_time - correction_start_time >= CORRECTION_DURATION:
                    # Re-evaluate desired angle; if still not center, renew correction
                    if desired_servo_angle != SERVO_CENTER:
                        correction_start_time = current_time
                        correction_angle = desired_servo_angle
                        robot.set_servo(correction_angle)
                        status_text = "Driving (renewed correction)"
                        print(f"‚ÜîÔ∏è Straight correction renewed. Servo angle: {correction_angle}")
                    else:
                        correction_active = False
            
            #robot.rotate_motor(SPEED_CRUISE)
            robot.set_state_speed(state.name)
            
        elif state == RobotState.TURN_INIT:
            # Initialize turning: set servo & motor for turn, store yaw/time
            status_text = f"Turning {direction}"
            turn_start_yaw = wrap_deg(yaw)
            turn_start_time = current_time
            turn_reference_side_distance = robot.d_right if direction == "LEFT" else robot.d_left
        
            # Grid-snap current heading, target next cardinal (uses global HEADING_STEP)
            base_cardinal = snap_to_grid(turn_start_yaw, HEADING_STEP)
            delta = +90.0 if direction == "LEFT" else -90.0
            target_heading = wrap_deg(base_cardinal + delta)
        
            print(f"üîÑ Turn initiated {direction}. "
                  f"L: {robot.d_left if robot.d_left is not None else 0:.1f} cm, "
                  f"R: {robot.d_right if robot.d_right is not None else 0:.1f} cm, "
                  f"target={target_heading:.1f}¬∞")
        
            angle = TURN_ANGLE_LEFT if direction == "LEFT" else TURN_ANGLE_RIGHT
            robot.set_servo(angle)
            robot.set_state_speed(state.name)
            state = RobotState.TURNING
            
        elif state == RobotState.TURNING:
            # Stop the turn when we hit the absolute target heading (with guards)
            yaw_now = wrap_deg(yaw)
            heading_error = wrap_deg(target_heading - yaw_now)   # signed
            turned_rel = wrap_deg(yaw_now - turn_start_yaw)      # relative turn in this corner
        
            stop_condition = False
        
            # A) absolute-heading tolerance, but only after some rotation
            if abs(heading_error) <= HEADING_TOL and abs(turned_rel) >= MIN_TURN_ANGLE:
                print("Stop Turn - Absolute heading matched")
                stop_condition = True
        
            # B) safety: timeout / max angle
            if current_time - turn_start_time > TURN_TIMEOUT:
                print("Stop Turn - Max turn time")
                stop_condition = True
            if abs(turned_rel) >= MAX_TURN_ANGLE:
                print("Stop Turn - Max turn angle")
                stop_condition = True
            
            # C: side distance convergence (monitor opposite wall)
            # Optional side-distance guard (simple: stop when it changed enough)
            side_distance_monitor = robot.d_left if direction == "RIGHT" else robot.d_right
            MIN_SIDE_CHANGE = 5  # cm
            if side_distance_monitor is not None and turn_reference_side_distance is not None:
                if abs(side_distance_monitor - turn_reference_side_distance) >= MIN_SIDE_CHANGE:
                    print("Stop Turn - Opposite distance changed enough")
                    stop_condition = True

                # (Optional) keep your distance-based stop as extra fail-safe if you like:
            # if robot.d_front is not None and robot.d_front > FRONT_SAFE_DISTANCE:
            #     stop_condition = True
        
            if stop_condition:
                robot.stop_motor()
                robot.set_servo(SERVO_CENTER)
                last_turn_time = current_time
        
                # snap internal yaw to target so drift doesn't accumulate
                yaw = target_heading
        
                turn_count += 1
                if turn_count % 4 == 0:
                    lap_count += 1
                    print(f"‚úÖ Lap completed! Total laps: {lap_count}")
                    if MAX_LAPS > 0 and lap_count >= MAX_LAPS:
                        robot.set_servo(SERVO_CENTER)
                        robot.set_state_speed(state.name)
                        time.sleep(POST_LAP_DURATION)
                        robot.stop_motor()
                        loop_flag = False
                        state = RobotState.STOPPED
                        status_text = f"Stopped - Max Laps ({MAX_LAPS}) reached"
                        continue
        
                post_turn_start = current_time
                state = RobotState.POST_TURN
                status_text = "Driving (post-turn)"
           
        elif state == RobotState.POST_TURN:
            # brief trim towards the absolute target heading
            yaw_now = wrap_deg(yaw)
            err = wrap_deg(target_heading - yaw_now)
        
            if current_time - post_turn_start < POST_TURN_DURATION:
                trim = -Kp_trim * err  # small P control towards target
                servo_cmd = max(SERVO_MIN_ANGLE, min(SERVO_MAX_ANGLE, SERVO_CENTER + trim))
                robot.set_servo(servo_cmd)
                robot.set_state_speed(state.name)
                status_text = "Driving (post-turn align)"
            else:
                robot.set_servo(SERVO_CENTER)
                state = RobotState.CRUISE
                status_text = "Driving (cruise)"

        elif state == RobotState.STOPPED:
            # motors must be stopped; remain stopped until loop_flag cleared by GUI or user
            robot.stop_motor()
            status_text = "Stopped"
            # state will remain STOPPED until user restarts loop via GUI (as requested "as is")
            # keep sleeping to avoid busy loop
            time.sleep(LOOP_DELAY)
            # do not auto-reset turn_count/lap_count here; that happens in stop_loop()
            continue

        # small delay to yield CPU
        time.sleep(LOOP_DELAY)


# ===============================
# GUI SECTION
# ===============================
def launch_gui():
    """Initialize Tkinter GUI, matplotlib plots, sliders, and status indicators."""
    global btn_readings, btn_start, btn_stop, root, canvas
    global ax_front, ax_side, ax_angle
    global front_line, left_line, right_line, angle_line
    global status_circle, status_canvas, status_text_id, lbl_status
    global lbl_turns, lbl_laps
    global sliders_frame, slider_vars, btn_export

    root = tk.Tk()
    root.title("VivaLaVida Robot Control")

    slider_vars = {}

    # ---------- Matplotlib Figure ----------
    fig, (ax_front, ax_side, ax_angle) = plt.subplots(3, 1, figsize=(6, 8))
    fig.tight_layout(pad=3.0)

    ax_front.set_ylim(0, 350)
    ax_front.set_title("Front Sensor")
    ax_front.grid(True)
    front_line, = ax_front.plot([], [], color="blue")

    ax_side.set_ylim(-150, 150)
    ax_side.set_title("Left (+Y) vs Right (-Y) Sensors")
    ax_side.grid(True)
    ax_side.axhline(0, color="black")
    left_line, = ax_side.plot([], [], color="green")
    right_line, = ax_side.plot([], [], color="orange")

    ax_angle.set_ylim(-180, 180)
    ax_angle.set_title("Yaw Angle")
    ax_angle.grid(True)
    angle_line, = ax_angle.plot([], [], color="purple")

    # ---------- Buttons ----------
    btn_readings = tk.Button(root, text="Start Readings", command=start_readings,
                             width=20, height=2, bg="blue", fg="white")
    btn_start = tk.Button(root, text="Start Loop", command=start_loop,
                          width=20, height=2, bg="green", fg="white", state="disabled")
    btn_stop = tk.Button(root, text="Stop Loop", command=stop_loop,
                         width=20, height=2, bg="red", fg="white", state="disabled")
  
    # ---------- Status Labels ----------
    lbl_status = tk.Label(root, text="Idle", font=("Arial", 14))
    lbl_turns = tk.Label(root, text=f"Turns: {turn_count}", font=("Arial", 14))
    lbl_laps = tk.Label(root, text=f"Laps: {lap_count}", font=("Arial", 14))

    # ---------- Circular Status Indicator ----------
    status_canvas = tk.Canvas(root, width=100, height=100, highlightthickness=0, bg=root.cget("bg"))
    status_circle = status_canvas.create_oval(10, 10, 90, 90, fill="grey", outline="")
    status_text_id = status_canvas.create_text(50, 50, text="IDLE", fill="white", font=("Arial", 14, "bold"))

    # ---------- Sliders Frame ----------
    sliders_frame = tk.LabelFrame(root, text="Parameters", padx=10, pady=10)
    sliders_frame.grid(row=0, column=1, rowspan=8, sticky="ns", padx=10, pady=5)

    # ---------- Column 3 frame for actions ----------
    actions_frame = tk.LabelFrame(root, text="Actions", padx=10, pady=10)
    actions_frame.grid(row=0, column=2, rowspan=8, sticky="ns", padx=10, pady=5)

    # ---------- Two-column layout ----------
    btn_readings.grid(row=0, column=0, sticky="ew", padx=5, pady=2)
    btn_start.grid(row=1, column=0, sticky="ew", padx=5, pady=2)
    btn_stop.grid(row=2, column=0, sticky="ew", padx=5, pady=2)
    lbl_status.grid(row=3, column=0, pady=5)
    lbl_turns.grid(row=4, column=0, pady=2)
    lbl_laps.grid(row=5, column=0, pady=2)
    status_canvas.grid(row=6, column=0, pady=5)

    canvas = FigureCanvasTkAgg(fig, master=root)
    canvas.get_tk_widget().grid(row=7, column=0, sticky="nsew", padx=5, pady=5)

    root.grid_columnconfigure(0, weight=1)  # main buttons + plots
    root.grid_columnconfigure(1, weight=0)  # sliders
    root.grid_columnconfigure(2, weight=0)  # actions
    root.grid_rowconfigure(7, weight=1)     # plot row

    # ---------- Slider Definitions ----------
    slider_groups = {
        "Speeds": [
            ("Cruise Speed", "SPEED_CRUISE", 0, 100, "int"),
            ("Turn Init Speed", "SPEED_TURN_INIT", 0, 100, "int"),
            ("Turn Speed", "SPEED_TURN", 0, 100, "int"),            
            ("Post Turn Speed", "SPEED_POST_TURN", 0, 100, "int")
        ],
        "Driving & Safety, Wall following, Turns": [
            ("Turn angle Left", "TURN_ANGLE_LEFT", 55, 90, "int"),
            ("Turn angle Right", "TURN_ANGLE_RIGHT", 90, 125, "int"),
            ("Soft side Margin (cm)", "SOFT_MARGIN", 0, 75, "int"),
            ("Max Angle Correction dif at Soft Margin (o)", "MAX_CORRECTION", 0, 30, "int"),
            ("Stop Threshold (cm)", "STOP_THRESHOLD", 0, 100, "int"),
            ("Front Turn Trigger (cm)", "FRONT_TURN_TRIGGER", 50, 150, "int"),
            ("Turn Decision Threshold (Left/Right) (cm)", "TURN_DECISION_THRESHOLD", 0, 200, "int"),
            ("Turn Timeout (s)", "TURN_TIMEOUT", 0.1, 10, "float"),
            ("Max Turn Angle (o)", "MAX_TURN_ANGLE", 60, 150, "int"),
            ("Post Turn Duration (s)", "POST_TURN_DURATION", 0, 5, "float"),
            ("Turn Lockout (s)", "TURN_LOCKOUT", 0.1, 5, "float")
        ],
        "Other": [
            ("Sensor Filter N (Median)", "N_READINGS", 1, 10, "int"),
            ("Max Laps - 0 for infinite", "MAX_LAPS", 0, 20, "int"),
            ("Filter Smoothness (alpha)", "FILTER_ALPHA", 0.05, 0.9, "float"),
            ("Max Jump (cm)", "FILTER_JUMP", 5, 999, "int"),
        ]
    }

    # ---------- Create Sliders ----------
    for group_name, sliders in slider_groups.items():
        group_frame = tk.LabelFrame(sliders_frame, text=group_name, padx=5, pady=5)
        group_frame.pack(fill="x", pady=5)
        for label_text, var_name, vmin, vmax, vartype in sliders:
            frame = tk.Frame(group_frame)
            frame.pack(fill="x", pady=2)

            if vartype == "float":
                var = tk.DoubleVar(value=globals()[var_name])
                res = 0.1
            else:
                var = tk.IntVar(value=globals()[var_name])
                res = 1

            slider_vars[var_name] = var

            scale = tk.Scale(frame, from_=vmin, to=vmax, orient="horizontal",
                             variable=var, resolution=res)
            scale.pack(side="left", fill="x", expand=True)

            lbl_val = tk.Label(frame, text=f"{label_text}: {var.get()}", width=25, anchor="w")
            lbl_val.pack(side="right", padx=5)

            def make_callback(lbl, name, var, label_text):
                def callback(value, label_text=label_text):
                    globals()[name] = var.get()
                    if name == "MAX_LAPS" and var.get() == 0:
                        lbl.config(text=f"{label_text}: ‚àû")
                    else:
                        lbl.config(text=f"{label_text}: {var.get():.1f}" if isinstance(var.get(), float) else f"{label_text}: {var.get()}")
                return callback

            scale.config(command=make_callback(lbl_val, var_name, var, label_text))

    # ---------- Buttons under sliders ----------
    btn_export = tk.Button(actions_frame, text="Export CSV", command=export_data_csv,
                       width=20, height=2, bg="purple", fg="white")
    btn_export.pack(pady=10, fill="x")

    btn_save_sliders = tk.Button(actions_frame, text="Save Sliders", command=save_sliders_json,
                             width=20, height=2, bg="green", fg="white")
    btn_save_sliders.pack(pady=5, fill="x")

    btn_load_sliders = tk.Button(actions_frame, text="Load Sliders", command=load_sliders_json,
                             width=20, height=2, bg="blue", fg="white")
    btn_load_sliders.pack(pady=5, fill="x")

    # ===============================
    # GUI Update Functions (nested)
    # ===============================
    def status_color(state: str) -> str:
        if "Stopped" in state:
            return "red"
        elif "Turning" in state:
            return "yellow"
        elif "Driving" in state:
            return "green"
        elif "Loop Started" in state or "Sensor readings started" in state:
            return "blue"
        else:
            return "grey"

    def status_label(state: str) -> str:
        if "Stopped" in state:
            return "STOP"
        elif "Turning" in state:
            return "TURN"
        elif "Driving" in state:
            return "GO"
        elif "Loop Started" in state:
            return "LOOP"
        elif "Sensor readings started" in state:
            return "READ"
        else:
            return "IDLE"

    def update_status():
        lbl_status.config(text=status_text)
        status_canvas.itemconfig(status_circle, fill=status_color(status_text))
        status_canvas.itemconfig(status_text_id, text=status_label(status_text))
        lbl_turns.config(text=f"Turns: {turn_count}")
        lbl_laps.config(text=f"Laps: {lap_count}" if slider_vars["MAX_LAPS"].get() > 0 else f"Laps: {lap_count}/‚àû")
        root.after(200, update_status)

    _prev_label_pos = {"front": None, "left": None, "right": None, "angle": None}
    def update_plot():
        #global _prev_label_pos
        nonlocal _prev_label_pos

        if time_data:
            # Update lines
            front_line.set_data(range(len(front_data)), front_data)
            left_line.set_data(range(len(left_data)), left_data)
            right_line.set_data(range(len(right_data)), [-v for v in right_data])
            angle_line.set_data(range(len(angle_data)), angle_data)
    
            # Set axis limits
            ax_front.set_xlim(0, MAX_POINTS)
            ax_side.set_xlim(0, MAX_POINTS)
            ax_angle.set_xlim(0, MAX_POINTS)
    
            # Remove previous text annotations
            for ax in [ax_front, ax_side, ax_angle]:
                for t in ax.texts:
                    t.remove()
    
            # Helper for smoothing
            def smooth_move(prev, target, alpha=0.3):
                if prev is None:
                    return target
                return prev + alpha * (target - prev)
    
            # ----------------------------
            # FRONT SENSOR
            # ----------------------------
            if len(front_data) > 0:
                x = len(front_data) - 1
                y_target = front_data[-1]
                y_prev = _prev_label_pos["front"]
                y_smooth = smooth_move(y_prev, y_target)
                _prev_label_pos["front"] = y_smooth
                ax_front.text(x, y_smooth, f"{y_target:.1f} cm", color="blue",
                              fontsize=9, fontweight="bold", va="bottom", ha="left")
    
            # ----------------------------
            # LEFT SENSOR
            # ----------------------------
            if len(left_data) > 0:
                x = len(left_data) - 1
                y_target = left_data[-1]
                y_prev = _prev_label_pos["left"]
                y_smooth = smooth_move(y_prev, y_target)
                _prev_label_pos["left"] = y_smooth
                ax_side.text(x, y_smooth, f"L: {y_target:.1f} cm", color="green",
                             fontsize=9, fontweight="bold", va="bottom", ha="left")
    
            # ----------------------------
            # RIGHT SENSOR
            # ----------------------------
            if len(right_data) > 0:
                x = len(right_data) - 1
                y_target = -right_data[-1]
                y_prev = _prev_label_pos["right"]
                y_smooth = smooth_move(y_prev, y_target)
                _prev_label_pos["right"] = y_smooth
                ax_side.text(x, y_smooth, f"R: {right_data[-1]:.1f} cm", color="orange",
                             fontsize=9, fontweight="bold", va="bottom", ha="left")
    
            # ----------------------------
            # YAW ANGLE
            # ----------------------------
            if len(angle_data) > 0:
                x = len(angle_data) - 1
                y_target = angle_data[-1]
                y_prev = _prev_label_pos["angle"]
                y_smooth = smooth_move(y_prev, y_target)
                _prev_label_pos["angle"] = y_smooth
                ax_angle.text(x, y_smooth, f"{y_target:.1f}¬∞", color="purple",
                              fontsize=9, fontweight="bold", va="bottom", ha="left")
    
            # ----------------------------
            # Dynamic Y-axis scaling for yaw
            # ----------------------------
            #if angle_data:
            #    min_angle = min(angle_data)
            #    max_angle = max(angle_data)
            #    if max_angle - min_angle > 180:
            #        ax_angle.set_ylim(-180, 180)
            #    else:
            #        ax_angle.set_ylim(min_angle - 10, max_angle + 10)
    
            # Draw updated plots
            canvas.draw()
    
        root.after(100, update_plot) 
        
    def on_closing():
        stop_loop()
        #try:
        #    for pin in [xshut_left, xshut_right, xshut_front, xshut_back]:
        #        if pin is not None:
        #            pin.value = False
        #    time.sleep(0.1)  # give sensors time to power down
        #except NameError:
        #    pass  # pins not initialized, skip

        # Stop all ToF sensors cleanly
        for sensor in [vl53_left, vl53_right, vl53_front, vl53_back]:
            if sensor is not None:
                try:
                    sensor.stop_continuous()
                except Exception as e:
                    print(f"Warning: could not stop sensor {sensor}: {e}")
        
        GPIO.cleanup()
        root.destroy()

    root.protocol("WM_DELETE_WINDOW", on_closing)
    update_status()
    update_plot()
    root.mainloop()

# ===============================
# GUI UPDATE FUNCTIONS (duplicate helpers used outside nested GUI function)
# ===============================
def status_color(state: str) -> str:
    if "Stopped" in state:
        return "red"
    elif "Turning" in state:
        return "yellow"
    elif "Driving" in state:
        return "green"
    elif "Loop Started" in state or "Sensor readings started" in state:
        return "blue"
    else:
        return "grey"

def status_label(state: str) -> str:
    if "Stopped" in state:
        return "STOP"
    elif "Turning" in state:
        return "TURN"
    elif "Driving" in state:
        return "GO"
    elif "Loop Started" in state:
        return "LOOP"
    elif "Sensor readings started" in state:
        return "READ"
    else:
        return "IDLE"

def update_status():
    lbl_status.config(text=status_text)
    status_canvas.itemconfig(status_circle, fill=status_color(status_text))
    status_canvas.itemconfig(status_text_id, text=status_label(status_text))
    lbl_turns.config(text=f"Turns: {turn_count}")
    lbl_laps.config(text=f"Laps: {lap_count}" if slider_vars["MAX_LAPS"].get() > 0 else f"Laps: {lap_count}/‚àû")
    root.after(200, update_status)

def update_plot():
    if time_data:
        front_line.set_data(range(len(front_data)), front_data)
        left_line.set_data(range(len(left_data)), left_data)
        right_line.set_data(range(len(right_data)), [-v for v in right_data])
        angle_line.set_data(range(len(angle_data)), angle_data)

        ax_front.set_xlim(0, MAX_POINTS)
        ax_side.set_xlim(0, MAX_POINTS)
        ax_angle.set_xlim(0, MAX_POINTS)

        #if angle_data:
        #    min_angle = min(angle_data)
        #    max_angle = max(angle_data)
        #    if max_angle - min_angle > 180:
        #        ax_angle.set_ylim(-180, 180)
        #    else:
        #        ax_angle.set_ylim(min_angle - 10, max_angle + 10)

        canvas.draw()

    root.after(100, update_plot)

def on_closing():
    stop_loop()
    GPIO.cleanup()
    root.destroy()

# -------------------------
# Start / Stop
# -------------------------

def start_readings():
    global readings_flag, status_text
    readings_flag = True
    status_text = "Sensor readings started"
    btn_readings.config(state="disabled")
    btn_start.config(state="normal")

    # Start background sensor thread once
    if not hasattr(start_readings, "sensor_thread_started"):
        threading.Thread(target=sensor_reader, daemon=True).start()
        #threading.Thread(target=robot_loop, daemon=True).start()
        #start_readings.thread_started = True
        start_readings.sensor_thread_started = True

def start_loop():
    """Start the robot driving loop."""
    global loop_flag, status_text
    if not readings_flag:
        print("Start sensor readings first!")
        return

    loop_flag = True
    status_text = "üöó Loop Started"
    btn_start.config(state="disabled")
    btn_stop.config(state="normal")

    if not hasattr(start_loop, "loop_thread_started"):
      threading.Thread(target=robot_loop, daemon=True).start()
      start_loop.loop_thread_started = True

def stop_loop():
    """Stop the robot loop and motor."""
    global loop_flag, status_text, turn_count, lap_count, locked_turn_direction
    loop_flag = False
    robot.stop_motor()
    status_text = "Stopped"
    btn_start.config(state="normal")
    btn_stop.config(state="disabled")

    # Reset counters
    turn_count = 0
    lap_count = 0
    lbl_turns.config(text=f"Turns: {turn_count}")
    lbl_laps.config(text=f"Laps: {lap_count}")

    # Reset direction lock so a new session can re-choose
    locked_turn_direction = None

# -------------------------
# Export to CSV
# -------------------------
def export_data_csv():
    filename = f"viva_data_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
    slider_values = {name: var.get() for name, var in slider_vars.items()}

    with open(filename, mode='w', newline='') as file:
        writer = csv.writer(file)
        header = [
            "Time (s)", "Front (cm)", "Left (cm)", "Right (cm)", "Yaw (deg)",
            "State", "Turns", "Laps", "Servo Angle", "Speed", "Turning", "Direction"
        ]
        header += [name for name in slider_values.keys()]
        writer.writerow(header)

        for i in range(len(time_data)):
            row = [
                round(time_data[i], 2),
                round(front_data[i], 2),
                round(left_data[i], 2),
                round(right_data[i], 2),
                round(angle_data[i], 2),
                state_data[i],
                turn_count,
                lap_count,
                globals().get("servo_angle", 0),  # latest steering
                globals().get("SPEED_CRUISE", 0),
                "YES" if "TURNING" in state_data[i] else "NO",
                globals().get("locked_turn_direction", "")
            ]
            row += [slider_values[name] for name in slider_values.keys()]
            writer.writerow(row)

    print(f"‚úÖ Data exported to {filename}")

# -------------------------
# Save/Load Slider Config
# -------------------------
def save_sliders_json():
    default_filename = f"sliders_config_{datetime.now().strftime('%Y%m%d')}.json"
    file_path = fd.asksaveasfilename(initialdir=BASE_DIR,
                                     initialfile=default_filename,
                                     defaultextension=".json",
                                     filetypes=[("JSON files", "*.json")],
                                     title="Save Slider Configuration")
    if file_path:
        data = {name: var.get() for name, var in slider_vars.items()}
        with open(file_path, "w") as f:
            json.dump(data, f, indent=4)
        print(f"Slider values saved to {file_path}")

def load_sliders_json():
    file_path = fd.askopenfilename(initialdir=BASE_DIR,
                                   defaultextension=".json",
                                   filetypes=[("JSON files", "*.json")],
                                   title="Load Slider Configuration")
    if file_path:
        try:
            with open(file_path, "r") as f:
                data = json.load(f)
            for name, value in data.items():
                if name in slider_vars:
                    slider_vars[name].set(value)
                    globals()[name] = value
            print(f"Sliders restored from {file_path}")
        except Exception as e:
            print(f"Failed to load sliders: {e}")

# ===============================
# MAIN
# ===============================

#if __name__ == "__main__":
#    launch_gui()

if __name__ == "__main__":
    print(f"Starting VivaLaVida Autonomous Drive - GUI mode: {USE_GUI}")
    
    if USE_GUI:
        launch_gui()
    else:
        # Start the sensor reading thread
        sensor_thread = threading.Thread(target=sensor_reader, daemon=True)
        sensor_thread.start()
        print("Headless mode: waiting for START button...")
        try:
            # Wait for button press (GPIO input goes LOW when pressed)
            while GPIO.input(START_BTN) == 1:
                time.sleep(0.05)
            print("‚úÖ START button pressed! Beginning autonomous loop...")
            readings_flag = True
            time.sleep(2)  # wait 2 seconds before starting loop
            loop_flag = True
            print("Starting main robot loop...")
            # Start robot loop in this thread (blocking)
            robot_loop()
        except KeyboardInterrupt:
            print("\n‚ùå Keyboard interrupt received. Stopping robot loop.")
            loop_flag = False
