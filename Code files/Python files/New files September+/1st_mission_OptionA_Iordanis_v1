# ==============================
# ðŸš— Autonomous Wall-Following Robot
# With PID centering, adaptive speed, and pivot turns
# ==============================

# --- Import required libraries ---
import time                                   # Provides timing functions
import RPi.GPIO as GPIO                       # Controls Raspberry Pi GPIO pins
from board import SCL, SDA                    # Import I2C pins (SCL/SDA)
import busio                                  # I2C communication
from adafruit_pca9685 import PCA9685          # Controls PCA9685 PWM driver

# ==============================
# ðŸ”§ CONFIGURATION VARIABLES
# ==============================

START_DELAY = 2                               # Delay before robot starts (seconds)
LOOP_DELAY = 0.1                              # Delay between control loop cycles (seconds)

TARGET_DISTANCE = 50.0                        # Desired distance from wall (cm)
KP = 1.0                                      # Proportional gain for PID
KI = 0.0                                      # Integral gain for PID
KD = 0.8                                      # Derivative gain for PID

SERVO_CHANNEL = 0                             # PCA9685 channel connected to steering servo
SERVO_MIN_ANGLE = 50                          # Minimum safe servo angle
SERVO_MAX_ANGLE = 130                         # Maximum safe servo angle
SERVO_CENTER = 90                             # Servo center angle (straight ahead)

MOTOR_FWD = 1                                 # PCA9685 channel for forward motor control
MOTOR_REV = 2                                 # PCA9685 channel for reverse motor control
SPEED_CRUISE = 20                             # Normal driving speed
SPEED_SLOW = 15                               # Slow speed near corners
SPEED_TURN = 10                               # Speed during turning/pivoting

TRIG_FRONT, ECHO_FRONT = 22, 23               # GPIO pins for front ultrasonic sensor
TRIG_LEFT, ECHO_LEFT = 27, 17                 # GPIO pins for left ultrasonic sensor
TRIG_RIGHT, ECHO_RIGHT = 5, 6                 # GPIO pins for right ultrasonic sensor

CORNER_TRIGGER = 45.0                         # Distance threshold (cm) to trigger a corner turn
WALL_DETECT_THRESHOLD = 80                    # Threshold (cm) for detecting new wall after turning

# ==============================
# ðŸ”§ INITIALIZATION
# ==============================

turns_completed = 0                           # Counter for number of turns completed
direction = "left"                            # Default turn direction
turning = False                               # Flag to indicate if robot is currently turning
integral = 0                                  # Integral term for PID
last_error = 0                                # Last error for PID derivative calculation

time.sleep(START_DELAY)                       # Wait before starting movement

i2c = busio.I2C(SCL, SDA)                     # Create I2C interface
pca = PCA9685(i2c)                            # Initialize PCA9685 board
pca.frequency = 50                            # Set PWM frequency to 50Hz (for servos)

GPIO.setmode(GPIO.BCM)                        # Use BCM GPIO pin numbering
for trig in [TRIG_FRONT, TRIG_LEFT, TRIG_RIGHT]:  # Initialize trigger pins
    GPIO.setup(trig, GPIO.OUT)                # Set trigger pin as output
    GPIO.output(trig, GPIO.LOW)               # Start with LOW signal
for echo in [ECHO_FRONT, ECHO_LEFT, ECHO_RIGHT]:  # Initialize echo pins
    GPIO.setup(echo, GPIO.IN)                 # Set echo pin as input

# ==============================
# ðŸ”§ HELPER FUNCTIONS
# ==============================

def rotate_motor(speed):
    """ Rotate motor forward or backward based on speed """
    duty_cycle = int(min(max(abs(speed), 0), 100) / 100 * 65535)  # Convert % speed to duty cycle
    if speed >= 0:                                                # Forward direction
        pca.channels[MOTOR_FWD].duty_cycle = duty_cycle           # Apply duty cycle to forward channel
        pca.channels[MOTOR_REV].duty_cycle = 0                    # Stop reverse channel
    else:                                                         # Reverse direction
        pca.channels[MOTOR_FWD].duty_cycle = 0                    # Stop forward channel
        pca.channels[MOTOR_REV].duty_cycle = duty_cycle           # Apply duty cycle to reverse channel

def stop_motor():
    """ Stop both forward and reverse motor outputs """
    pca.channels[MOTOR_FWD].duty_cycle = 0                        # Set forward channel to 0
    pca.channels[MOTOR_REV].duty_cycle = 0                        # Set reverse channel to 0

def set_servo_angle(angle):
    """ Set steering servo to a specific angle """
    angle = max(SERVO_MIN_ANGLE, min(SERVO_MAX_ANGLE, angle))     # Clamp angle within safe range
    pulse_min, pulse_max = 1000, 2000                             # Servo pulse width range (Âµs)
    pulse = int(pulse_min + (pulse_max - pulse_min) * ((angle - SERVO_MIN_ANGLE) / (SERVO_MAX_ANGLE - SERVO_MIN_ANGLE)))  
    pca.channels[SERVO_CHANNEL].duty_cycle = int(pulse * 65535 / 20000)  # Convert to PCA9685 duty cycle

def get_distance(trigger_pin, echo_pin):
    """ Measure distance using ultrasonic sensor """
    GPIO.output(trigger_pin, GPIO.HIGH)                           # Send 10Âµs pulse to trigger
    time.sleep(0.00001)                                           # Wait 10 microseconds
    GPIO.output(trigger_pin, GPIO.LOW)                            # Stop pulse

    pulse_start, pulse_end = None, None                           # Initialize timing variables
    timeout = time.time() + 0.02                                  # Set timeout to avoid hanging

    while GPIO.input(echo_pin) == GPIO.LOW:                       # Wait for echo pulse to start
        pulse_start = time.time()                                 # Record start time
        if pulse_start > timeout:                                 # Timeout condition
            return None

    while GPIO.input(echo_pin) == GPIO.HIGH:                      # Wait for echo pulse to end
        pulse_end = time.time()                                   # Record end time
        if pulse_end > timeout:                                   # Timeout condition
            return None

    if pulse_start and pulse_end:                                 # If valid pulse recorded
        pulse_duration = pulse_end - pulse_start                  # Calculate duration of echo pulse
        return (pulse_duration * 34300) / 2                       # Convert duration to distance in cm
    return None                                                   # Return None if failed

# ==============================
# ðŸ”§ MAIN LOOP
# ==============================

try:
    while True:
        distance_front = get_distance(TRIG_FRONT, ECHO_FRONT)     # Measure front wall distance
        distance_left = get_distance(TRIG_LEFT, ECHO_LEFT)        # Measure left wall distance
        distance_right = get_distance(TRIG_RIGHT, ECHO_RIGHT)     # Measure right wall distance

        if not turning and distance_front and distance_front < CORNER_TRIGGER:  # Check if a corner is detected
            turning = True                                        # Set turning flag
            turns_completed += 1                                  # Increment turn counter

            if distance_left and distance_right:                  # Choose direction based on more space
                direction = "left" if distance_left > distance_right else "right"
            else:                                                 # If one sensor fails, choose available one
                direction = "left" if distance_left else "right"

            print(f"âš¡ Corner detected â†’ Turn {turns_completed}: {direction.upper()}")

            rotate_motor(0)                                       # Stop before turning
            time.sleep(0.05)                                      # Small pause before turn

            target_angle = 60 if direction == "left" else 120     # Target servo angle for turn
            step = -5 if direction == "left" else 5               # Step increment for servo sweep
            current_angle = SERVO_CENTER                          # Start turning from center
            MAX_STEPS = abs(SERVO_CENTER - target_angle) // abs(step)  # Max steps for safety

            for _ in range(MAX_STEPS):                            # Loop to perform turn
                set_servo_angle(current_angle)                    # Adjust servo angle
                rotate_motor(SPEED_TURN)                          # Move forward slowly (pivot-like)
                time.sleep(0.05)                                  # Short delay for movement

                distance_left = get_distance(TRIG_LEFT, ECHO_LEFT)  # Re-check left wall
                distance_right = get_distance(TRIG_RIGHT, ECHO_RIGHT)  # Re-check right wall

                if direction == "left" and distance_right and distance_right < WALL_DETECT_THRESHOLD:  
                    break                                         # Stop turn if new wall detected
                elif direction == "right" and distance_left and distance_left < WALL_DETECT_THRESHOLD:  
                    break                                         # Stop turn if new wall detected

                current_angle += step                             # Increment servo angle

            set_servo_angle(SERVO_CENTER)                         # Reset servo to straight
            rotate_motor(SPEED_TURN)                              # Move forward slowly to align
            time.sleep(0.2)                                       # Short stabilization delay

            turning = False                                       # Clear turning flag
            print("âœ… Turn completed, resuming forward motion")

        if distance_left and distance_right:                      # If both side sensors are valid
            error = distance_left - distance_right                # Use difference for centering
        else:                                                     # If only one wall is available
            side_sensor = distance_left if direction == "left" else distance_right
            if side_sensor is None:                               # If sensor fails
                print("âš ï¸ Sensor error, skipping cycle")
                continue
            error = TARGET_DISTANCE - side_sensor                 # Error from target distance

        integral += error                                         # Update integral term
        derivative = error - last_error                           # Calculate derivative
        output = KP * error + KI * integral + KD * derivative     # PID formula
        last_error = error                                        # Store last error

        new_angle = SERVO_CENTER + output                         # Apply PID correction to servo
        set_servo_angle(new_angle)                                # Move servo

        if distance_front and distance_front < 60:                # Adjust speed based on front wall
            rotate_motor(SPEED_SLOW)                              # Slow down if close to wall
        else:
            rotate_motor(SPEED_CRUISE)                            # Normal cruising speed

        mode = "CENTERING" if (distance_left and distance_right) else f"{direction.upper()} wall"  
        print(f"Mode={mode} | L={distance_left} cm R={distance_right} cm | F={distance_front} cm | Error={error:.2f} | Servo={new_angle:.1f}")

        time.sleep(LOOP_DELAY)                                    # Wait before next cycle

except KeyboardInterrupt:                                         # Catch CTRL+C interruption
    print("ðŸ›‘ Stopping safely...")
    stop_motor()                                                  # Stop motors
    GPIO.cleanup()                                                # Reset GPIO pins
