#----------------------------------------------------------------------------------------------------------------------
# Autonomous drive - VivaLaVida
# v4 - 23/9/2025
# v4.1 - remove camera, add logging - 24/9/2025
# v4.2 - improved turn logic and timeout slider - 24/9/2025
# v4.3 - graph and turn improvements - 25/9/2025
# v4.5 - rewrite
# v4.5 - new turn logic with PID clear after turn
#
# Logic description
# - Continuously read ultrasonic sensor distances: front, left, and right.
# - Emergency stop: If front distance < stop threshold, halt immediately to prevent collisions.
# - Initiate turn:
#     Triggered when front distance < configured turn trigger.
#     Robot chooses the side with the greater distance (left or right) to turn toward.
#     Moves forward while steering to avoid the obstacle.
#     Turn ends when front sensor reads clear OR timeout reached.
# - PID wall-following:
#     Compares left and right distances to maintain a centered path between walls.
#     Adjusts servo angle based on PID output to correct robot heading.
#     Applies a deadzone to ignore small deviations and prevent oscillations.
#     Uses adaptive PID gains to respond more aggressively to larger errors.
# - Continuous forward motion: Robot moves at configured cruise speed unless turning or stopped.
# - Integrates real-time sensor input, PID steering, and turning logic for autonomous navigation and obstacle avoidance.
#-----------------------------------------------------------------------------------------------------------------------
# Features:
# - Continuous sensor reading (front, left, right)
# - Emergency stop if obstacle too close
# - Turn decision: turn only if front < trigger AND a side > 100cm
# - PID wall-following between walls
# - Tkinter GUI with integer/float sliders for robot parameters
# - Matplotlib plots embedded in GUI
# - Safe shutdown and cleanup
#----------------------------------------------------------------------------------------------------------------------

#----------------------------------------------------------------------------------------------------------------------
# Autonomous drive - VivaLaVida
# v4.6c - Fully commented version
# Features:
# - PID wall-following
# - Obstacle detection
# - Smooth turning with post-turn wait
# - Tkinter GUI with plotting
#----------------------------------------------------------------------------------------------------------------------

import tkinter as tk                         # Import Tkinter for GUI
from tkinter import ttk                      # Import themed Tkinter widgets
import matplotlib.pyplot as plt              # Import matplotlib for plotting
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg  # Embed plots in Tkinter
import threading                             # For running robot loop in background
import time                                  # Time functions for delays and timers
import queue                                 # Thread-safe queue for plotting data
import RPi.GPIO as GPIO                       # Raspberry Pi GPIO control
from board import SCL, SDA                   # I2C pins for servo/motor driver
import busio                                 # I2C communication
from adafruit_pca9685 import PCA9685         # PWM driver for motors/servo
from collections import deque                # Sliding window for median filter

# ===============================
# CONFIGURATION VARIABLES
# ===============================
TARGET_DISTANCE = 40                          # Desired distance from walls (cm)
FRONT_TURN_TRIGGER = 80                        # Trigger distance to start turn (cm)
STOP_THRESHOLD = 20                            # Emergency stop threshold (cm)
CROSSOVER_THRESHOLD = 80                       # Threshold to safely end turn (cm)
SPEED_CRUISE = 20                              # Normal forward speed
SPEED_TURN = 20                                # Speed while turning
TURN_ANGLE_LEFT = 65                            # Servo angle for left turn
TURN_ANGLE_RIGHT = 115                          # Servo angle for right turn
SERVO_CENTER = 90                               # Servo center angle
SERVO_MIN_ANGLE = 50                            # Minimum servo angle
SERVO_MAX_ANGLE = 130                           # Maximum servo angle
KP, KI, KD = 1, 0, 2                            # PID constants (proportional, integral, derivative)
DEADZONE = 4                                   # Deadzone to avoid small oscillations
MAX_LAPS = 3                                   # Optional max laps
N_READINGS = 5                                 # Median filter window size
TURN_TIMEOUT = 3.0                              # Maximum turn duration in seconds
TURN_LOCKOUT = 4.0                              # Minimum time between consecutive turns

# ===============================
# HARDWARE SETUP
# ===============================
GPIO.setmode(GPIO.BCM)                          # Use Broadcom GPIO numbering
GPIO.setwarnings(False)                         # Disable GPIO warnings

i2c = busio.I2C(SCL, SDA)                       # Initialize I2C bus
pca = PCA9685(i2c)                               # Initialize PCA9685 driver
pca.frequency = 50                               # Set PWM frequency to 50Hz

SERVO_CHANNEL = 0                               # Servo PWM channel
MOTOR_FWD = 1                                   # Forward motor channel
MOTOR_REV = 2                                   # Reverse motor channel

# Ultrasonic sensor pin assignments
TRIG_FRONT, ECHO_FRONT = 22, 23
TRIG_LEFT, ECHO_LEFT = 27, 17
TRIG_RIGHT, ECHO_RIGHT = 5, 6

# Configure trigger pins as outputs
for trig in [TRIG_FRONT, TRIG_LEFT, TRIG_RIGHT]:
    GPIO.setup(trig, GPIO.OUT)
    GPIO.output(trig, GPIO.LOW)                  # Initialize low

# Configure echo pins as inputs
for echo in [ECHO_FRONT, ECHO_LEFT, ECHO_RIGHT]:
    GPIO.setup(echo, GPIO.IN)

# ===============================
# TKINTER GUI SETUP
# ===============================
root = tk.Tk()                                  # Create main Tkinter window
root.title("Robot Control Panel")              # Set window title

# Frame to hold variable sliders
var_frame = ttk.LabelFrame(root, text="Variables")
var_frame.grid(row=0, column=0, padx=5, pady=5, sticky="nw")

# Dictionary of variables: name -> [initial value, min, max, type]
variables = {
    "TARGET_DISTANCE": [TARGET_DISTANCE, 10, 50, "int"],
    "FRONT_TURN_TRIGGER": [FRONT_TURN_TRIGGER, 50, 150, "int"],
    "STOP_THRESHOLD": [STOP_THRESHOLD, 10, 30, "int"],
    "CROSSOVER_THRESHOLD": [CROSSOVER_THRESHOLD, 10, 100, "int"],
    "SPEED_CRUISE": [SPEED_CRUISE, 5, 50, "int"],
    "SPEED_TURN": [SPEED_TURN, 5, 30, "int"],
    "TURN_ANGLE_LEFT": [TURN_ANGLE_LEFT, 45, 90, "int"],
    "TURN_ANGLE_RIGHT": [TURN_ANGLE_RIGHT, 90, 135, "int"],
    "SERVO_CENTER": [SERVO_CENTER, 50, 130, "int"],
    "SERVO_MIN_ANGLE": [SERVO_MIN_ANGLE, 0, 90, "int"],
    "SERVO_MAX_ANGLE": [SERVO_MAX_ANGLE, 90, 180, "int"],
    "KP": [KP, 0, 5, "float"],
    "KI": [KI, 0, 5, "float"],
    "KD": [KD, 0, 5, "float"],
    "DEADZONE": [DEADZONE, 0, 10, "int"],
    "MAX_LAPS": [MAX_LAPS, 1, 20, "int"],
    "TURN_TIMEOUT": [TURN_TIMEOUT, 0.2, 5.0, "float"],
    "TURN_LOCKOUT": [TURN_LOCKOUT, 0.5, 10.0, "float"],
}

slider_vars = {}                               # Store Tkinter variables for sliders
row = 0
for name, (val, mn, mx, vtype) in variables.items():
    ttk.Label(var_frame, text=name).grid(row=row, column=0, sticky="w")  # Label for variable
    if vtype == "int":
        slider_var = tk.IntVar(value=val)
        def round_int(val, var=slider_var):
            var.set(int(float(val)))           # Round float to int
        slider = ttk.Scale(var_frame, from_=mn, to=mx, variable=slider_var,
                           orient=tk.HORIZONTAL, length=150, command=round_int)
    else:
        slider_var = tk.DoubleVar(value=val)
        def round_float(val, var=slider_var):
            var.set(round(float(val), 2))     # Round float to 2 decimals
        slider = ttk.Scale(var_frame, from_=mn, to=mx, variable=slider_var,
                           orient=tk.HORIZONTAL, length=150, command=round_float)
    slider.grid(row=row, column=1, sticky="w")   # Place slider
    ttk.Label(var_frame, textvariable=slider_var, width=7).grid(row=row, column=2)  # Show value
    slider_vars[name] = slider_var               # Save variable
    row += 1

# ===============================
# STATUS LABEL
# ===============================
status_var = tk.StringVar(value="Idle")         # Robot status
ttk.Label(root, text="Status:").grid(row=6, column=0, sticky="w", pady=5)  # Static label
status_label = ttk.Label(root, textvariable=status_var, foreground="blue")
status_label.grid(row=6, column=0, sticky="e", padx=5, pady=5)              # Dynamic label

# ===============================
# CONTROL FLAGS
# ===============================
reading_flag = False                             # Enable sensor reading
loop_flag = False                                # Enable main robot loop
paused_flag = False                              # Pause flag

# ===============================
# BUTTON FUNCTIONS
# ===============================
def start_reading():
    global reading_flag
    reading_flag = True
    update_control_buttons()

def start_loop():
    global loop_flag, paused_flag
    loop_flag = True
    paused_flag = False
    update_control_buttons()

def pause_loop():
    global paused_flag
    paused_flag = True
    update_control_buttons()

def resume_loop():
    global paused_flag
    paused_flag = False
    update_control_buttons()

def stop_robot():
    global reading_flag, loop_flag, paused_flag
    reading_flag = False
    loop_flag = False
    paused_flag = False
    robot.stop_motor()
    status_var.set("Stopped")
    update_control_buttons()

def update_control_buttons():
    if reading_flag:
        start_read_button.config(state="disabled")
    else:
        start_read_button.config(state="normal")
    if loop_flag and not paused_flag:
        start_loop_button.config(state="disabled")
        pause_button.config(state="normal")
        resume_button.config(state="disabled")
    elif loop_flag and paused_flag:
        start_loop_button.config(state="disabled")
        pause_button.config(state="disabled")
        resume_button.config(state="normal")
    else:
        start_loop_button.config(state="normal")
        pause_button.config(state="disabled")
        resume_button.config(state="disabled")

# Place buttons
start_read_button = ttk.Button(root, text="Start Reading", command=start_reading)
start_read_button.grid(row=1, column=0, pady=5)
start_loop_button = ttk.Button(root, text="Start Loop", command=start_loop)
start_loop_button.grid(row=2, column=0, pady=5)
pause_button = ttk.Button(root, text="Pause Loop", command=pause_loop, state="disabled")
pause_button.grid(row=3, column=0, pady=5)
resume_button = ttk.Button(root, text="Resume", command=resume_loop, state="disabled")
resume_button.grid(row=4, column=0, pady=5)
stop_button = ttk.Button(root, text="Stop", command=stop_robot)
stop_button.grid(row=5, column=0, pady=5)

# ===============================
# PLOTS SETUP
# ===============================
fig, (ax_front, ax_side) = plt.subplots(2,1, figsize=(6,6))  # Two subplots: front sensor & side sensors
fig.tight_layout(pad=3.0)                                     # Add padding between plots

# Front sensor plot
ax_front.set_ylim(0,350)                                       # y-axis range in cm
ax_front.grid(True)                                             # Show grid
ax_front.set_title("Front Sensor")                              # Title
front_line, = ax_front.plot([],[], color="blue")               # Line object for dynamic plotting

# Side sensors plot (left vs right)
ax_side.set_ylim(-150,150)                                      # y-axis range (mirrored)
ax_side.grid(True)
ax_side.set_title("Left vs Right Sensors (Mirrored)")
ax_side.axhline(0, color="black", linewidth=1)                 # Center line
left_line, = ax_side.plot([],[], color="green")                # Left sensor line
right_line, = ax_side.plot([],[], color="orange")              # Right sensor line

# Embed matplotlib figure into Tkinter
canvas = FigureCanvasTkAgg(fig, master=root)
canvas.get_tk_widget().grid(row=0, column=1, rowspan=7, padx=10, pady=5)

# ===============================
# DATA STORAGE FOR PLOTTING
# ===============================
time_data = []       # Time steps for plotting
front_data = []      # Front sensor readings
left_data = []       # Left sensor readings
right_data = []      # Right sensor readings

data_queue = queue.Queue()   # Thread-safe queue for passing sensor data to GUI

# ===============================
# ROBOT CONTROLLER CLASS
# ===============================
class RobotController:
    """Encapsulates motor, servo, and sensor control with PID and turn logic."""
    def __init__(self, pca, slider_vars):
        self.pca = pca                           # PCA9685 object
        self.slider_vars = slider_vars           # GUI sliders for real-time parameters
        self.integral = 0                        # PID integral term
        self.last_error = 0                       # Last PID error (for derivative)
        self.front_history = deque(maxlen=N_READINGS)  # Sliding window for median filter
        self.left_history = deque(maxlen=N_READINGS)
        self.right_history = deque(maxlen=N_READINGS)

    # -------------------------------
    # SERVO CONTROL
    # -------------------------------
    def set_servo(self, angle):
        """Set servo to a given angle within limits."""
        min_angle = self.slider_vars["SERVO_MIN_ANGLE"].get()      # Min allowed
        max_angle = self.slider_vars["SERVO_MAX_ANGLE"].get()      # Max allowed
        angle = max(min_angle, min(max_angle, angle))              # Clamp
        pulse = int(1000 + (2000-1000)*((angle-min_angle)/(max_angle-min_angle)))  # Convert to PWM
        self.pca.channels[SERVO_CHANNEL].duty_cycle = int(pulse*65535/20000)       # Apply PWM

    # -------------------------------
    # MOTOR CONTROL
    # -------------------------------
    def rotate_motor(self, speed):
        """Rotate motor: positive = forward, negative = backward."""
        duty_cycle = int(min(max(abs(speed),0),100)/100*65535)    # Convert speed 0-100 to PWM
        if speed >= 0:                                            # Forward
            self.pca.channels[MOTOR_FWD].duty_cycle = duty_cycle
            self.pca.channels[MOTOR_REV].duty_cycle = 0
        else:                                                     # Backward
            self.pca.channels[MOTOR_FWD].duty_cycle = 0
            self.pca.channels[MOTOR_REV].duty_cycle = duty_cycle

    def stop_motor(self):
        """Stop both motors immediately."""
        self.pca.channels[MOTOR_FWD].duty_cycle = 0
        self.pca.channels[MOTOR_REV].duty_cycle = 0

    # -------------------------------
    # ULTRASONIC DISTANCE MEASUREMENT
    # -------------------------------
    def get_distance(self, trig, echo):
        """Measure distance from ultrasonic sensor in cm."""
        try:
            GPIO.output(trig, True)               # Send trigger pulse
            time.sleep(0.00001)                   # 10us pulse
            GPIO.output(trig, False)
            start_time = time.perf_counter()
            while GPIO.input(echo) == 0:          # Wait for echo start
                if time.perf_counter() - start_time > 0.02:
                    return None                   # Timeout
            pulse_start = time.perf_counter()
            while GPIO.input(echo) == 1:          # Wait for echo end
                if time.perf_counter() - pulse_start > 0.02:
                    return None                   # Timeout
            pulse_end = time.perf_counter()
            return (pulse_end - pulse_start) * 17150  # Convert to cm
        except:
            return None                            # Return None on failure

    # -------------------------------
    # FILTERED DISTANCE
    # -------------------------------
    def filtered_distance(self, trig, echo, history):
        """Median-filtered distance using sliding window."""
        d = self.get_distance(trig, echo)       # Get raw reading
        if d is not None:
            history.append(d)                    # Add to history
        if history:
            sorted_hist = sorted(history)        # Sort for median
            mid = len(sorted_hist)//2
            return (sorted_hist[mid-1]+sorted_hist[mid])/2 if len(sorted_hist)%2==0 else sorted_hist[mid]
        return None

    # -------------------------------
    # PID CONTROL
    # -------------------------------
    def pid_control(self, d_left, d_right):
        """Compute PID output based on left/right distances."""
        error = 0
        if d_left is not None and d_right is not None:
            error = d_left - d_right             # Difference between walls
        elif d_left is not None:
            error = self.slider_vars["TARGET_DISTANCE"].get() - d_left
        elif d_right is not None:
            error = d_right - self.slider_vars["TARGET_DISTANCE"].get()

        self.integral += error                    # Update integral term
        self.integral = max(min(self.integral,100),-100)  # Clamp integral
        derivative = error - self.last_error      # Compute derivative
        self.last_error = error

        kp = self.slider_vars["KP"].get()         # Proportional gain
        kd = self.slider_vars["KD"].get()         # Derivative gain
        if abs(error) > 20:                       # Adaptive gain for large errors
            kp *= 1.5
            kd *= 2.0

        output = kp*error + kd*derivative         # PID output
        if abs(error) < self.slider_vars["DEADZONE"].get():  # Apply deadzone
            output = 0
        return output

    # -------------------------------
    # TURN DECISION
    # -------------------------------
    def turn_decision(self, d_left, d_right):
        """Decide which direction to turn based on side distances."""
        threshold = 100
        if d_left is not None and d_left > threshold:
            return "LEFT"
        elif d_right is not None and d_right > threshold:
            return "RIGHT"
        if d_left is not None and d_right is not None:
            return "LEFT" if d_left > d_right else "RIGHT"
        elif d_left is not None:
            return "LEFT"
        elif d_right is not None:
            return "RIGHT"
        return "LEFT"                               # Fallback

robot = RobotController(pca, slider_vars)        # Instantiate robot controller

# ===============================
# ROBOT MAIN LOOP
# ===============================
def robot_loop():
    t = 0                                        # Time counter
    turning = False                              # Turn flag
    turn_start_time = 0
    last_turn_time = -slider_vars["TURN_LOCKOUT"].get()  # Last turn timestamp
    post_turn_wait = False
    post_turn_start = 0
    POST_TURN_DURATION = 0.5                     # Wait 0.5s after turn
    direction = None
    d_front = d_left = d_right = None

    while True:
        current_time = time.monotonic()         # High-res clock

        # -------------------------------
        # SENSOR READING
        # -------------------------------
        if reading_flag:
            d_front = robot.filtered_distance(TRIG_FRONT, ECHO_FRONT, robot.front_history)
            d_left = robot.filtered_distance(TRIG_LEFT, ECHO_LEFT, robot.left_history)
            d_right = robot.filtered_distance(TRIG_RIGHT, ECHO_RIGHT, robot.right_history)
            data_queue.put((t, d_front or 0, d_left or 0, d_right or 0))  # Send to GUI
            t += 1

        # -------------------------------
        # MAIN CONTROL
        # -------------------------------
        if loop_flag and not paused_flag:
            if d_front is not None and d_front < slider_vars["STOP_THRESHOLD"].get():  # Emergency stop
                robot.stop_motor()
                root.after(0, lambda: status_var.set("Stopped! Obstacle ahead"))
                time.sleep(0.05)
                continue

            # Post-turn wait to prevent sudden opposite turn
            if post_turn_wait:
                if time.monotonic() - post_turn_start < POST_TURN_DURATION:
                    robot.set_servo(slider_vars["SERVO_CENTER"].get())  # Keep centered
                    robot.rotate_motor(slider_vars["SPEED_CRUISE"].get())
                    root.after(0, lambda: status_var.set("Driving (post-turn)"))
                    time.sleep(0.05)
                    continue
                else:
                    post_turn_wait = False

            # Initiate turn if needed
            front_trigger = slider_vars["FRONT_TURN_TRIGGER"].get()
            if (not turning
                and not post_turn_wait
                and d_front is not None
                and d_front < front_trigger
                and (d_left > 100 or d_right > 100)
                and current_time - last_turn_time >= slider_vars["TURN_LOCKOUT"].get()):
                
                direction = robot.turn_decision(d_left, d_right)
                turning = True
                turn_start_time = current_time
                root.after(0, lambda dir=direction: status_var.set(f"Turning {dir}"))

            # -------------------------------
            # TURN LOGIC
            # -------------------------------
            if turning:
                angle = slider_vars["TURN_ANGLE_LEFT"].get() if direction=="LEFT" else slider_vars["TURN_ANGLE_RIGHT"].get()
                side_distance = d_left if direction=="LEFT" else d_right
                robot.set_servo(angle)
                robot.rotate_motor(slider_vars["SPEED_TURN"].get())

                # End turn condition
                if ((d_front is not None and d_front > front_trigger and side_distance > slider_vars["TARGET_DISTANCE"].get())
                    or (current_time - turn_start_time > slider_vars["TURN_TIMEOUT"].get())):

                    robot.stop_motor()                  # Stop motors
                    robot.set_servo(slider_vars["SERVO_CENTER"].get())  # Center servo
                    robot.integral = 0                   # Reset PID
                    robot.last_error = 0
                    turning = False
                    last_turn_time = current_time
                    post_turn_wait = True
                    post_turn_start = time.monotonic()   # Start post-turn wait

                time.sleep(0.05)
                continue

            # -------------------------------
            # PID WALL-FOLLOWING
            # -------------------------------
            output = robot.pid_control(d_left, d_right)
            new_angle = slider_vars["SERVO_CENTER"].get() + output
            new_angle = max(slider_vars["SERVO_MIN_ANGLE"].get(),
                            min(slider_vars["SERVO_MAX_ANGLE"].get(), new_angle))
            robot.set_servo(new_angle)
            robot.rotate_motor(slider_vars["SPEED_CRUISE"].get())
            root.after(0, lambda: status_var.set("Driving"))

        time.sleep(0.05)   # Small loop delay

# Start robot loop in background
threading.Thread(target=robot_loop, daemon=True).start()

# ===============================
# CLEANUP ON EXIT
# ===============================
def on_closing():
    try:
        robot.stop_motor()    # Stop motors
        GPIO.cleanup()        # Cleanup GPIO pins
    except:
        pass
    root.destroy()           # Close GUI

root.protocol("WM_DELETE_WINDOW", on_closing)  # Bind window close event
root.mainloop()                                # Start Tkinter main loop

